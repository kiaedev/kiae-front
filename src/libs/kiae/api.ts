/* tslint:disable */
/* eslint-disable */
/**
 * kiae
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AppApplication
 */
export interface AppApplication {
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'pid'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'image'?: string;
    /**
     * 
     * @type {Array<ProjectPort>}
     * @memberof AppApplication
     */
    'ports'?: Array<ProjectPort>;
    /**
     * 
     * @type {AppStatus}
     * @memberof AppApplication
     */
    'status'?: AppStatus;
    /**
     * 
     * @type {AppSize}
     * @memberof AppApplication
     */
    'size'?: AppSize;
    /**
     * 
     * @type {number}
     * @memberof AppApplication
     */
    'replicas'?: number;
    /**
     * 
     * @type {Array<ProjectConfiguration>}
     * @memberof AppApplication
     */
    'configs'?: Array<ProjectConfiguration>;
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @interface AppListResponse
 */
export interface AppListResponse {
    /**
     * 
     * @type {Array<AppApplication>}
     * @memberof AppListResponse
     */
    'items'?: Array<AppApplication>;
    /**
     * 
     * @type {string}
     * @memberof AppListResponse
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AppSize = {
    Nano: 'SIZE_NANO',
    Mirco: 'SIZE_MIRCO',
    Mini: 'SIZE_MINI',
    Small: 'SIZE_SMALL',
    Medium: 'SIZE_MEDIUM',
    Large: 'SIZE_LARGE',
    Xlarge: 'SIZE_XLARGE',
    Xxlarge: 'SIZE_XXLARGE'
} as const;

export type AppSize = typeof AppSize[keyof typeof AppSize];


/**
 * 
 * @export
 * @enum {string}
 */

export const AppStatus = {
    Pending: 'STATUS_PENDING',
    Running: 'STATUS_RUNNING',
    Stopped: 'STATUS_STOPPED'
} as const;

export type AppStatus = typeof AppStatus[keyof typeof AppStatus];


/**
 * 
 * @export
 * @interface GooglerpcStatus
 */
export interface GooglerpcStatus {
    /**
     * 
     * @type {number}
     * @memberof GooglerpcStatus
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GooglerpcStatus
     */
    'message'?: string;
    /**
     * 
     * @type {Array<ProtobufAny>}
     * @memberof GooglerpcStatus
     */
    'details'?: Array<ProtobufAny>;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'pid'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'image'?: string;
    /**
     * 
     * @type {Array<ProjectPort>}
     * @memberof InlineObject
     */
    'ports'?: Array<ProjectPort>;
    /**
     * 
     * @type {AppStatus}
     * @memberof InlineObject
     */
    'status'?: AppStatus;
    /**
     * 
     * @type {AppSize}
     * @memberof InlineObject
     */
    'size'?: AppSize;
    /**
     * 
     * @type {number}
     * @memberof InlineObject
     */
    'replicas'?: number;
    /**
     * 
     * @type {Array<ProjectConfiguration>}
     * @memberof InlineObject
     */
    'configs'?: Array<ProjectConfiguration>;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    'pid'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    'image'?: string;
    /**
     * 
     * @type {Array<ProjectPort>}
     * @memberof InlineObject1
     */
    'ports'?: Array<ProjectPort>;
    /**
     * 
     * @type {AppStatus}
     * @memberof InlineObject1
     */
    'status'?: AppStatus;
    /**
     * 
     * @type {AppSize}
     * @memberof InlineObject1
     */
    'size'?: AppSize;
    /**
     * 
     * @type {number}
     * @memberof InlineObject1
     */
    'replicas'?: number;
    /**
     * 
     * @type {Array<ProjectConfiguration>}
     * @memberof InlineObject1
     */
    'configs'?: Array<ProjectConfiguration>;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    'intro'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    'git'?: string;
    /**
     * 
     * @type {Array<ProjectImage>}
     * @memberof InlineObject2
     */
    'images'?: Array<ProjectImage>;
    /**
     * 
     * @type {Array<ProjectPort>}
     * @memberof InlineObject2
     */
    'ports'?: Array<ProjectPort>;
    /**
     * 
     * @type {Array<ProjectConfiguration>}
     * @memberof InlineObject2
     */
    'configs'?: Array<ProjectConfiguration>;
    /**
     * 
     * @type {Array<ProjectMiddleware>}
     * @memberof InlineObject2
     */
    'middlewares'?: Array<ProjectMiddleware>;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    'intro'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    'git'?: string;
    /**
     * 
     * @type {Array<ProjectImage>}
     * @memberof InlineObject3
     */
    'images'?: Array<ProjectImage>;
    /**
     * 
     * @type {Array<ProjectPort>}
     * @memberof InlineObject3
     */
    'ports'?: Array<ProjectPort>;
    /**
     * 
     * @type {Array<ProjectConfiguration>}
     * @memberof InlineObject3
     */
    'configs'?: Array<ProjectConfiguration>;
    /**
     * 
     * @type {Array<ProjectMiddleware>}
     * @memberof InlineObject3
     */
    'middlewares'?: Array<ProjectMiddleware>;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ProjectConfigLevel = {
    Team: 'CONFIG_LEVEL_TEAM',
    Project: 'CONFIG_LEVEL_PROJECT',
    App: 'CONFIG_LEVEL_APP'
} as const;

export type ProjectConfigLevel = typeof ProjectConfigLevel[keyof typeof ProjectConfigLevel];


/**
 * 
 * @export
 * @interface ProjectConfiguration
 */
export interface ProjectConfiguration {
    /**
     * 
     * @type {string}
     * @memberof ProjectConfiguration
     */
    'filename'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectConfiguration
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectConfiguration
     */
    'mountPath'?: string;
    /**
     * 
     * @type {ProjectConfigLevel}
     * @memberof ProjectConfiguration
     */
    'level'?: ProjectConfigLevel;
    /**
     * 
     * @type {string}
     * @memberof ProjectConfiguration
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectConfiguration
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ProjectImage
 */
export interface ProjectImage {
    /**
     * 
     * @type {string}
     * @memberof ProjectImage
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectImage
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectImage
     */
    'latest'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectImage
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectImage
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ProjectListResponse
 */
export interface ProjectListResponse {
    /**
     * 
     * @type {Array<ProjectProject>}
     * @memberof ProjectListResponse
     */
    'items'?: Array<ProjectProject>;
    /**
     * 
     * @type {string}
     * @memberof ProjectListResponse
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @interface ProjectMiddleware
 */
export interface ProjectMiddleware {
    /**
     * 
     * @type {string}
     * @memberof ProjectMiddleware
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectMiddleware
     */
    'type'?: string;
    /**
     * 
     * @type {{ [key: string]: ProtobufAny; }}
     * @memberof ProjectMiddleware
     */
    'properties'?: { [key: string]: ProtobufAny; };
}
/**
 * 
 * @export
 * @interface ProjectPort
 */
export interface ProjectPort {
    /**
     * 
     * @type {number}
     * @memberof ProjectPort
     */
    'port'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectPort
     */
    'protocol'?: string;
}
/**
 * 
 * @export
 * @interface ProjectProject
 */
export interface ProjectProject {
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'intro'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'git'?: string;
    /**
     * 
     * @type {Array<ProjectImage>}
     * @memberof ProjectProject
     */
    'images'?: Array<ProjectImage>;
    /**
     * 
     * @type {Array<ProjectPort>}
     * @memberof ProjectProject
     */
    'ports'?: Array<ProjectPort>;
    /**
     * 
     * @type {Array<ProjectConfiguration>}
     * @memberof ProjectProject
     */
    'configs'?: Array<ProjectConfiguration>;
    /**
     * 
     * @type {Array<ProjectMiddleware>}
     * @memberof ProjectProject
     */
    'middlewares'?: Array<ProjectMiddleware>;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'updatedBy'?: string;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }  Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...  Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON  The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
    [key: string]: object | any;

    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof ProtobufAny
     */
    '@type'?: string;
}
/**
 * 
 * @export
 * @interface SettingsListReply
 */
export interface SettingsListReply {
    /**
     * 
     * @type {string}
     * @memberof SettingsListReply
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface SettingsUpdateReply
 */
export interface SettingsUpdateReply {
    /**
     * 
     * @type {string}
     * @memberof SettingsUpdateReply
     */
    'message'?: string;
}

/**
 * AppServiceApi - axios parameter creator
 * @export
 */
export const AppServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AppApplication} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceCreate: async (body: AppApplication, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('appServiceCreate', 'body', body)
            const localVarPath = `/api/v1/apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary rpc Start (AppStatusRequest) returns (AppStatusReply) {        option (google.api.http) = {            patch: \"/api/v1/apps/{id}/status\"            body: \"*\"        };    }    rpc Stop (AppStatusRequest) returns (AppStatusReply) {        option (google.api.http) = {            patch: \"/api/v1/apps/{id}/status\"            body: \"*\"        };    }
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('appServiceDelete', 'id', id)
            const localVarPath = `/api/v1/apps/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [pid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceList: async (pid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pid !== undefined) {
                localVarQueryParameter['pid'] = pid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceUpdate: async (id: string, body: InlineObject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('appServiceUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('appServiceUpdate', 'body', body)
            const localVarPath = `/api/v1/apps/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceUpdate2: async (id: string, body: InlineObject1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('appServiceUpdate2', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('appServiceUpdate2', 'body', body)
            const localVarPath = `/api/v1/apps/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppServiceApi - functional programming interface
 * @export
 */
export const AppServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AppApplication} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceCreate(body: AppApplication, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary rpc Start (AppStatusRequest) returns (AppStatusReply) {        option (google.api.http) = {            patch: \"/api/v1/apps/{id}/status\"            body: \"*\"        };    }    rpc Stop (AppStatusRequest) returns (AppStatusReply) {        option (google.api.http) = {            patch: \"/api/v1/apps/{id}/status\"            body: \"*\"        };    }
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [pid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceList(pid?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceList(pid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceUpdate(id: string, body: InlineObject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceUpdate(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceUpdate2(id: string, body: InlineObject1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceUpdate2(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AppServiceApi - factory interface
 * @export
 */
export const AppServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {AppApplication} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceCreate(body: AppApplication, options?: any): AxiosPromise<AppApplication> {
            return localVarFp.appServiceCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary rpc Start (AppStatusRequest) returns (AppStatusReply) {        option (google.api.http) = {            patch: \"/api/v1/apps/{id}/status\"            body: \"*\"        };    }    rpc Stop (AppStatusRequest) returns (AppStatusReply) {        option (google.api.http) = {            patch: \"/api/v1/apps/{id}/status\"            body: \"*\"        };    }
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceDelete(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.appServiceDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [pid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceList(pid?: string, options?: any): AxiosPromise<AppListResponse> {
            return localVarFp.appServiceList(pid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceUpdate(id: string, body: InlineObject, options?: any): AxiosPromise<AppApplication> {
            return localVarFp.appServiceUpdate(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceUpdate2(id: string, body: InlineObject1, options?: any): AxiosPromise<AppApplication> {
            return localVarFp.appServiceUpdate2(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppServiceApi - object-oriented interface
 * @export
 * @class AppServiceApi
 * @extends {BaseAPI}
 */
export class AppServiceApi extends BaseAPI {
    /**
     * 
     * @param {AppApplication} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceCreate(body: AppApplication, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary rpc Start (AppStatusRequest) returns (AppStatusReply) {        option (google.api.http) = {            patch: \"/api/v1/apps/{id}/status\"            body: \"*\"        };    }    rpc Stop (AppStatusRequest) returns (AppStatusReply) {        option (google.api.http) = {            patch: \"/api/v1/apps/{id}/status\"            body: \"*\"        };    }
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceDelete(id: string, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [pid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceList(pid?: string, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceList(pid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {InlineObject} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceUpdate(id: string, body: InlineObject, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {InlineObject1} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceUpdate2(id: string, body: InlineObject1, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceUpdate2(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectServiceApi - axios parameter creator
 * @export
 */
export const ProjectServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ProjectProject} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceCreate: async (body: ProjectProject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('projectServiceCreate', 'body', body)
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectServiceDelete', 'id', id)
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceList: async (name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceRead: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectServiceRead', 'id', id)
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject2} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceUpdate: async (id: string, body: InlineObject2, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectServiceUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('projectServiceUpdate', 'body', body)
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject3} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceUpdate2: async (id: string, body: InlineObject3, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectServiceUpdate2', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('projectServiceUpdate2', 'body', body)
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectServiceApi - functional programming interface
 * @export
 */
export const ProjectServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ProjectProject} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectServiceCreate(body: ProjectProject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectServiceCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectServiceDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectServiceDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectServiceList(name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectServiceList(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectServiceRead(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectServiceRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject2} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectServiceUpdate(id: string, body: InlineObject2, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectServiceUpdate(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject3} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectServiceUpdate2(id: string, body: InlineObject3, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectServiceUpdate2(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectServiceApi - factory interface
 * @export
 */
export const ProjectServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {ProjectProject} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceCreate(body: ProjectProject, options?: any): AxiosPromise<ProjectProject> {
            return localVarFp.projectServiceCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceDelete(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.projectServiceDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceList(name?: string, options?: any): AxiosPromise<ProjectListResponse> {
            return localVarFp.projectServiceList(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceRead(id: string, options?: any): AxiosPromise<ProjectProject> {
            return localVarFp.projectServiceRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject2} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceUpdate(id: string, body: InlineObject2, options?: any): AxiosPromise<ProjectProject> {
            return localVarFp.projectServiceUpdate(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject3} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceUpdate2(id: string, body: InlineObject3, options?: any): AxiosPromise<ProjectProject> {
            return localVarFp.projectServiceUpdate2(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectServiceApi - object-oriented interface
 * @export
 * @class ProjectServiceApi
 * @extends {BaseAPI}
 */
export class ProjectServiceApi extends BaseAPI {
    /**
     * 
     * @param {ProjectProject} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public projectServiceCreate(body: ProjectProject, options?: AxiosRequestConfig) {
        return ProjectServiceApiFp(this.configuration).projectServiceCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public projectServiceDelete(id: string, options?: AxiosRequestConfig) {
        return ProjectServiceApiFp(this.configuration).projectServiceDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public projectServiceList(name?: string, options?: AxiosRequestConfig) {
        return ProjectServiceApiFp(this.configuration).projectServiceList(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public projectServiceRead(id: string, options?: AxiosRequestConfig) {
        return ProjectServiceApiFp(this.configuration).projectServiceRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {InlineObject2} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public projectServiceUpdate(id: string, body: InlineObject2, options?: AxiosRequestConfig) {
        return ProjectServiceApiFp(this.configuration).projectServiceUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {InlineObject3} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public projectServiceUpdate2(id: string, body: InlineObject3, options?: AxiosRequestConfig) {
        return ProjectServiceApiFp(this.configuration).projectServiceUpdate2(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsServiceApi - axios parameter creator
 * @export
 */
export const SettingsServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsServiceList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsServiceApi - functional programming interface
 * @export
 */
export const SettingsServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsServiceList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingsListReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsServiceList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsServiceApi - factory interface
 * @export
 */
export const SettingsServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsServiceList(options?: any): AxiosPromise<SettingsListReply> {
            return localVarFp.settingsServiceList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsServiceApi - object-oriented interface
 * @export
 * @class SettingsServiceApi
 * @extends {BaseAPI}
 */
export class SettingsServiceApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsServiceApi
     */
    public settingsServiceList(options?: AxiosRequestConfig) {
        return SettingsServiceApiFp(this.configuration).settingsServiceList(options).then((request) => request(this.axios, this.basePath));
    }
}


