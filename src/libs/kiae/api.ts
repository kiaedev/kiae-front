/* tslint:disable */
/* eslint-disable */
/**
 * kiae
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const ActionPayloadAction = {
    Start: 'START',
    Stop: 'STOP',
    Restart: 'RESTART'
} as const;

export type ActionPayloadAction = typeof ActionPayloadAction[keyof typeof ActionPayloadAction];


/**
 * 
 * @export
 * @interface AppApplication
 */
export interface AppApplication {
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'pid'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'image'?: string;
    /**
     * 
     * @type {Array<ProjectPort>}
     * @memberof AppApplication
     */
    'ports'?: Array<ProjectPort>;
    /**
     * 
     * @type {AppStatus}
     * @memberof AppApplication
     */
    'status'?: AppStatus;
    /**
     * 
     * @type {AppSize}
     * @memberof AppApplication
     */
    'size'?: AppSize;
    /**
     * 
     * @type {number}
     * @memberof AppApplication
     */
    'replicas'?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AppApplication
     */
    'annotations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof AppApplication
     */
    'livenessProbeEnabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AppApplication
     */
    'readinessProbeEnabled'?: boolean;
    /**
     * 
     * @type {Array<ProjectConfiguration>}
     * @memberof AppApplication
     */
    'configs'?: Array<ProjectConfiguration>;
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @interface AppListResponse
 */
export interface AppListResponse {
    /**
     * 
     * @type {Array<AppApplication>}
     * @memberof AppListResponse
     */
    'items'?: Array<AppApplication>;
    /**
     * 
     * @type {string}
     * @memberof AppListResponse
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AppSize = {
    Nano: 'SIZE_NANO',
    Mirco: 'SIZE_MIRCO',
    Mini: 'SIZE_MINI',
    Small: 'SIZE_SMALL',
    Medium: 'SIZE_MEDIUM',
    Large: 'SIZE_LARGE',
    Xlarge: 'SIZE_XLARGE',
    Xxlarge: 'SIZE_XXLARGE'
} as const;

export type AppSize = typeof AppSize[keyof typeof AppSize];


/**
 * 
 * @export
 * @enum {string}
 */

export const AppStatus = {
    Created: 'STATUS_CREATED',
    Running: 'STATUS_RUNNING',
    Stopped: 'STATUS_STOPPED'
} as const;

export type AppStatus = typeof AppStatus[keyof typeof AppStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const ClaimPolicy = {
    Reuse: 'REUSE',
    Create: 'CREATE'
} as const;

export type ClaimPolicy = typeof ClaimPolicy[keyof typeof ClaimPolicy];


/**
 * 
 * @export
 * @interface EgressEgress
 */
export interface EgressEgress {
    /**
     * 
     * @type {string}
     * @memberof EgressEgress
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EgressEgress
     */
    'appid'?: string;
    /**
     * 
     * @type {EgressEgressType}
     * @memberof EgressEgress
     */
    'type'?: EgressEgressType;
    /**
     * 
     * @type {string}
     * @memberof EgressEgress
     */
    'name'?: string;
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof EgressEgress
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof EgressEgress
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof EgressEgress
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EgressEgressType = {
    Internal: 'INTERNAL',
    Internet: 'INTERNET'
} as const;

export type EgressEgressType = typeof EgressEgressType[keyof typeof EgressEgressType];


/**
 * 
 * @export
 * @interface EgressListResponse
 */
export interface EgressListResponse {
    /**
     * 
     * @type {Array<EgressEgress>}
     * @memberof EgressListResponse
     */
    'items'?: Array<EgressEgress>;
    /**
     * 
     * @type {string}
     * @memberof EgressListResponse
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @interface EntryEntry
 */
export interface EntryEntry {
    /**
     * 
     * @type {string}
     * @memberof EntryEntry
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntryEntry
     */
    'appid'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntryEntry
     */
    'gateway'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntryEntry
     */
    'host'?: string;
    /**
     * 
     * @type {EntryScope}
     * @memberof EntryEntry
     */
    'scope'?: EntryScope;
    /**
     * 
     * @type {Array<string>}
     * @memberof EntryEntry
     */
    'routeIds'?: Array<string>;
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof EntryEntry
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof EntryEntry
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntryEntry
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface EntryListResponse
 */
export interface EntryListResponse {
    /**
     * 
     * @type {Array<EntryEntry>}
     * @memberof EntryListResponse
     */
    'items'?: Array<EntryEntry>;
    /**
     * 
     * @type {string}
     * @memberof EntryListResponse
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EntryScope = {
    All: 'ALL',
    Partial: 'PARTIAL'
} as const;

export type EntryScope = typeof EntryScope[keyof typeof EntryScope];


/**
 * 
 * @export
 * @interface GooglerpcStatus
 */
export interface GooglerpcStatus {
    /**
     * 
     * @type {number}
     * @memberof GooglerpcStatus
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GooglerpcStatus
     */
    'message'?: string;
    /**
     * 
     * @type {Array<ProtobufAny>}
     * @memberof GooglerpcStatus
     */
    'details'?: Array<ProtobufAny>;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'id'?: string;
    /**
     * 
     * @type {EgressEgressType}
     * @memberof InlineObject
     */
    'type'?: EgressEgressType;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'name'?: string;
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof InlineObject
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {EgressEgressType}
     * @memberof InlineObject1
     */
    'type'?: EgressEgressType;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    'name'?: string;
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof InlineObject1
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject10
 */
export interface InlineObject10 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject10
     */
    'pid'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject10
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject10
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject10
     */
    'image'?: string;
    /**
     * 
     * @type {Array<ProjectPort>}
     * @memberof InlineObject10
     */
    'ports'?: Array<ProjectPort>;
    /**
     * 
     * @type {AppStatus}
     * @memberof InlineObject10
     */
    'status'?: AppStatus;
    /**
     * 
     * @type {AppSize}
     * @memberof InlineObject10
     */
    'size'?: AppSize;
    /**
     * 
     * @type {number}
     * @memberof InlineObject10
     */
    'replicas'?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InlineObject10
     */
    'annotations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject10
     */
    'livenessProbeEnabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject10
     */
    'readinessProbeEnabled'?: boolean;
    /**
     * 
     * @type {Array<ProjectConfiguration>}
     * @memberof InlineObject10
     */
    'configs'?: Array<ProjectConfiguration>;
    /**
     * 
     * @type {string}
     * @memberof InlineObject10
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject10
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject10
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject10
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject11
 */
export interface InlineObject11 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject11
     */
    'pid'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject11
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject11
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject11
     */
    'image'?: string;
    /**
     * 
     * @type {Array<ProjectPort>}
     * @memberof InlineObject11
     */
    'ports'?: Array<ProjectPort>;
    /**
     * 
     * @type {AppStatus}
     * @memberof InlineObject11
     */
    'status'?: AppStatus;
    /**
     * 
     * @type {AppSize}
     * @memberof InlineObject11
     */
    'size'?: AppSize;
    /**
     * 
     * @type {number}
     * @memberof InlineObject11
     */
    'replicas'?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InlineObject11
     */
    'annotations'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject11
     */
    'livenessProbeEnabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject11
     */
    'readinessProbeEnabled'?: boolean;
    /**
     * 
     * @type {Array<ProjectConfiguration>}
     * @memberof InlineObject11
     */
    'configs'?: Array<ProjectConfiguration>;
    /**
     * 
     * @type {string}
     * @memberof InlineObject11
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject11
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject11
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject11
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject12
 */
export interface InlineObject12 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    'appid'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    'name'?: string;
    /**
     * 
     * @type {ClaimPolicy}
     * @memberof InlineObject12
     */
    'policy'?: ClaimPolicy;
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    'instance'?: string;
    /**
     * 
     * @type {MiddlewareClaimStatus}
     * @memberof InlineObject12
     */
    'status'?: MiddlewareClaimStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject13
 */
export interface InlineObject13 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    'appid'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    'name'?: string;
    /**
     * 
     * @type {ClaimPolicy}
     * @memberof InlineObject13
     */
    'policy'?: ClaimPolicy;
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    'instance'?: string;
    /**
     * 
     * @type {MiddlewareClaimStatus}
     * @memberof InlineObject13
     */
    'status'?: MiddlewareClaimStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject14
 */
export interface InlineObject14 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject14
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject14
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject14
     */
    'type'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InlineObject14
     */
    'properties'?: { [key: string]: string; };
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof InlineObject14
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject14
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject14
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject15
 */
export interface InlineObject15 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject15
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject15
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject15
     */
    'type'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InlineObject15
     */
    'properties'?: { [key: string]: string; };
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof InlineObject15
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject15
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject15
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject16
 */
export interface InlineObject16 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject16
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject16
     */
    'intro'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject16
     */
    'git'?: string;
    /**
     * 
     * @type {Array<ProjectImage>}
     * @memberof InlineObject16
     */
    'images'?: Array<ProjectImage>;
    /**
     * 
     * @type {Array<ProjectPort>}
     * @memberof InlineObject16
     */
    'ports'?: Array<ProjectPort>;
    /**
     * 
     * @type {ProjectHealthProbe}
     * @memberof InlineObject16
     */
    'livenessProbe'?: ProjectHealthProbe;
    /**
     * 
     * @type {ProjectHealthProbe}
     * @memberof InlineObject16
     */
    'readinessProbe'?: ProjectHealthProbe;
    /**
     * 
     * @type {string}
     * @memberof InlineObject16
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject16
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject16
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject16
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject17
 */
export interface InlineObject17 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject17
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject17
     */
    'intro'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject17
     */
    'git'?: string;
    /**
     * 
     * @type {Array<ProjectImage>}
     * @memberof InlineObject17
     */
    'images'?: Array<ProjectImage>;
    /**
     * 
     * @type {Array<ProjectPort>}
     * @memberof InlineObject17
     */
    'ports'?: Array<ProjectPort>;
    /**
     * 
     * @type {ProjectHealthProbe}
     * @memberof InlineObject17
     */
    'livenessProbe'?: ProjectHealthProbe;
    /**
     * 
     * @type {ProjectHealthProbe}
     * @memberof InlineObject17
     */
    'readinessProbe'?: ProjectHealthProbe;
    /**
     * 
     * @type {string}
     * @memberof InlineObject17
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject17
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject17
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject17
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * 
     * @type {EgressEgressType}
     * @memberof InlineObject2
     */
    'type'?: EgressEgressType;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    'name'?: string;
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof InlineObject2
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    'gateway'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    'host'?: string;
    /**
     * 
     * @type {EntryScope}
     * @memberof InlineObject3
     */
    'scope'?: EntryScope;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject3
     */
    'routeIds'?: Array<string>;
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof InlineObject3
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    'path'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject4
     */
    'methods'?: Array<string>;
    /**
     * 
     * @type {RouteRouteType}
     * @memberof InlineObject4
     */
    'type'?: RouteRouteType;
    /**
     * 
     * @type {RouteForward}
     * @memberof InlineObject4
     */
    'forward'?: RouteForward;
    /**
     * 
     * @type {RouteRedirect}
     * @memberof InlineObject4
     */
    'redirect'?: RouteRedirect;
    /**
     * 
     * @type {RouteDirectResponse}
     * @memberof InlineObject4
     */
    'mock'?: RouteDirectResponse;
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof InlineObject4
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
    /**
     * 
     * @type {ActionPayloadAction}
     * @memberof InlineObject5
     */
    'action'?: ActionPayloadAction;
}
/**
 * 
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    'gateway'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    'host'?: string;
    /**
     * 
     * @type {EntryScope}
     * @memberof InlineObject6
     */
    'scope'?: EntryScope;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject6
     */
    'routeIds'?: Array<string>;
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof InlineObject6
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject7
 */
export interface InlineObject7 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject7
     */
    'gateway'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject7
     */
    'host'?: string;
    /**
     * 
     * @type {EntryScope}
     * @memberof InlineObject7
     */
    'scope'?: EntryScope;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject7
     */
    'routeIds'?: Array<string>;
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof InlineObject7
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject7
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject7
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject8
 */
export interface InlineObject8 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    'path'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject8
     */
    'methods'?: Array<string>;
    /**
     * 
     * @type {RouteRouteType}
     * @memberof InlineObject8
     */
    'type'?: RouteRouteType;
    /**
     * 
     * @type {RouteForward}
     * @memberof InlineObject8
     */
    'forward'?: RouteForward;
    /**
     * 
     * @type {RouteRedirect}
     * @memberof InlineObject8
     */
    'redirect'?: RouteRedirect;
    /**
     * 
     * @type {RouteDirectResponse}
     * @memberof InlineObject8
     */
    'mock'?: RouteDirectResponse;
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof InlineObject8
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject9
 */
export interface InlineObject9 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    'path'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject9
     */
    'methods'?: Array<string>;
    /**
     * 
     * @type {RouteRouteType}
     * @memberof InlineObject9
     */
    'type'?: RouteRouteType;
    /**
     * 
     * @type {RouteForward}
     * @memberof InlineObject9
     */
    'forward'?: RouteForward;
    /**
     * 
     * @type {RouteRedirect}
     * @memberof InlineObject9
     */
    'redirect'?: RouteRedirect;
    /**
     * 
     * @type {RouteDirectResponse}
     * @memberof InlineObject9
     */
    'mock'?: RouteDirectResponse;
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof InlineObject9
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const KiaeOpStatus = {
    Disabled: 'OP_STATUS_DISABLED',
    Enabled: 'OP_STATUS_ENABLED'
} as const;

export type KiaeOpStatus = typeof KiaeOpStatus[keyof typeof KiaeOpStatus];


/**
 * 
 * @export
 * @interface MiddlewareClaim
 */
export interface MiddlewareClaim {
    /**
     * 
     * @type {string}
     * @memberof MiddlewareClaim
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareClaim
     */
    'appid'?: string;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareClaim
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareClaim
     */
    'name'?: string;
    /**
     * 
     * @type {ClaimPolicy}
     * @memberof MiddlewareClaim
     */
    'policy'?: ClaimPolicy;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareClaim
     */
    'instance'?: string;
    /**
     * 
     * @type {MiddlewareClaimStatus}
     * @memberof MiddlewareClaim
     */
    'status'?: MiddlewareClaimStatus;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareClaim
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareClaim
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MiddlewareClaimStatus = {
    Unbound: 'UNBOUND',
    Bound: 'BOUND'
} as const;

export type MiddlewareClaimStatus = typeof MiddlewareClaimStatus[keyof typeof MiddlewareClaimStatus];


/**
 * 
 * @export
 * @interface MiddlewareClaimsResponse
 */
export interface MiddlewareClaimsResponse {
    /**
     * 
     * @type {Array<MiddlewareClaim>}
     * @memberof MiddlewareClaimsResponse
     */
    'items'?: Array<MiddlewareClaim>;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareClaimsResponse
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @interface MiddlewareInstance
 */
export interface MiddlewareInstance {
    /**
     * 
     * @type {string}
     * @memberof MiddlewareInstance
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareInstance
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareInstance
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareInstance
     */
    'type'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof MiddlewareInstance
     */
    'properties'?: { [key: string]: string; };
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof MiddlewareInstance
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareInstance
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareInstance
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface MiddlewareListResponse
 */
export interface MiddlewareListResponse {
    /**
     * 
     * @type {Array<MiddlewareInstance>}
     * @memberof MiddlewareListResponse
     */
    'items'?: Array<MiddlewareInstance>;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareListResponse
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ProjectConfigLevel = {
    Team: 'CONFIG_LEVEL_TEAM',
    Project: 'CONFIG_LEVEL_PROJECT',
    App: 'CONFIG_LEVEL_APP'
} as const;

export type ProjectConfigLevel = typeof ProjectConfigLevel[keyof typeof ProjectConfigLevel];


/**
 * 
 * @export
 * @interface ProjectConfiguration
 */
export interface ProjectConfiguration {
    /**
     * 
     * @type {string}
     * @memberof ProjectConfiguration
     */
    'filename'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectConfiguration
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectConfiguration
     */
    'mountPath'?: string;
    /**
     * 
     * @type {ProjectConfigLevel}
     * @memberof ProjectConfiguration
     */
    'level'?: ProjectConfigLevel;
    /**
     * 
     * @type {string}
     * @memberof ProjectConfiguration
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectConfiguration
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ProjectHealthProbe
 */
export interface ProjectHealthProbe {
    /**
     * 
     * @type {number}
     * @memberof ProjectHealthProbe
     */
    'port'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectHealthProbe
     */
    'path'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProjectHealthProbe
     */
    'periodSeconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectHealthProbe
     */
    'timeoutSeconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectHealthProbe
     */
    'successThreshold'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectHealthProbe
     */
    'failureThreshold'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectHealthProbe
     */
    'initialDelaySeconds'?: number;
}
/**
 * 
 * @export
 * @interface ProjectImage
 */
export interface ProjectImage {
    /**
     * 
     * @type {string}
     * @memberof ProjectImage
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectImage
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectImage
     */
    'latest'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectImage
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectImage
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ProjectListResponse
 */
export interface ProjectListResponse {
    /**
     * 
     * @type {Array<ProjectProject>}
     * @memberof ProjectListResponse
     */
    'items'?: Array<ProjectProject>;
    /**
     * 
     * @type {string}
     * @memberof ProjectListResponse
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @interface ProjectPort
 */
export interface ProjectPort {
    /**
     * 
     * @type {number}
     * @memberof ProjectPort
     */
    'port'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectPort
     */
    'protocol'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectPort
     */
    'appProtocol'?: string;
}
/**
 * 
 * @export
 * @interface ProjectProject
 */
export interface ProjectProject {
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'intro'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'git'?: string;
    /**
     * 
     * @type {Array<ProjectImage>}
     * @memberof ProjectProject
     */
    'images'?: Array<ProjectImage>;
    /**
     * 
     * @type {Array<ProjectPort>}
     * @memberof ProjectProject
     */
    'ports'?: Array<ProjectPort>;
    /**
     * 
     * @type {ProjectHealthProbe}
     * @memberof ProjectProject
     */
    'livenessProbe'?: ProjectHealthProbe;
    /**
     * 
     * @type {ProjectHealthProbe}
     * @memberof ProjectProject
     */
    'readinessProbe'?: ProjectHealthProbe;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'updatedBy'?: string;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }  Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...  Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON  The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
    [key: string]: object | any;

    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof ProtobufAny
     */
    '@type'?: string;
}
/**
 * 
 * @export
 * @interface RouteCors
 */
export interface RouteCors {
    /**
     * 
     * @type {boolean}
     * @memberof RouteCors
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof RouteCors
     */
    'allowOrigins'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RouteCors
     */
    'allowMethods'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RouteCors
     */
    'allowHeaders'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RouteCors
     */
    'exposeHeaders'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof RouteCors
     */
    'allowCredentials'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RouteCors
     */
    'maxAge'?: number;
}
/**
 * 
 * @export
 * @interface RouteDirectResponse
 */
export interface RouteDirectResponse {
    /**
     * 
     * @type {number}
     * @memberof RouteDirectResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof RouteDirectResponse
     */
    'body'?: string;
}
/**
 * 
 * @export
 * @interface RouteForward
 */
export interface RouteForward {
    /**
     * 
     * @type {RouteCors}
     * @memberof RouteForward
     */
    'cors'?: RouteCors;
    /**
     * 
     * @type {RouteRewrite}
     * @memberof RouteForward
     */
    'rewrite'?: RouteRewrite;
    /**
     * 
     * @type {RouteLimiter}
     * @memberof RouteForward
     */
    'limiter'?: RouteLimiter;
}
/**
 * 
 * @export
 * @interface RouteLimiter
 */
export interface RouteLimiter {
    /**
     * 
     * @type {boolean}
     * @memberof RouteLimiter
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RouteLimiter
     */
    'qps'?: number;
}
/**
 * 
 * @export
 * @interface RouteListResponse
 */
export interface RouteListResponse {
    /**
     * 
     * @type {Array<RouteRoute>}
     * @memberof RouteListResponse
     */
    'items'?: Array<RouteRoute>;
    /**
     * 
     * @type {string}
     * @memberof RouteListResponse
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @interface RouteRedirect
 */
export interface RouteRedirect {
    /**
     * 
     * @type {number}
     * @memberof RouteRedirect
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof RouteRedirect
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface RouteRewrite
 */
export interface RouteRewrite {
    /**
     * 
     * @type {boolean}
     * @memberof RouteRewrite
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RouteRewrite
     */
    'uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof RouteRewrite
     */
    'authority'?: string;
}
/**
 * 
 * @export
 * @interface RouteRoute
 */
export interface RouteRoute {
    /**
     * 
     * @type {string}
     * @memberof RouteRoute
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RouteRoute
     */
    'appid'?: string;
    /**
     * 
     * @type {string}
     * @memberof RouteRoute
     */
    'path'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RouteRoute
     */
    'methods'?: Array<string>;
    /**
     * 
     * @type {RouteRouteType}
     * @memberof RouteRoute
     */
    'type'?: RouteRouteType;
    /**
     * 
     * @type {RouteForward}
     * @memberof RouteRoute
     */
    'forward'?: RouteForward;
    /**
     * 
     * @type {RouteRedirect}
     * @memberof RouteRoute
     */
    'redirect'?: RouteRedirect;
    /**
     * 
     * @type {RouteDirectResponse}
     * @memberof RouteRoute
     */
    'mock'?: RouteDirectResponse;
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof RouteRoute
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof RouteRoute
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof RouteRoute
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof RouteRoute
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof RouteRoute
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RouteRouteType = {
    Forward: 'FORWARD',
    Redirect: 'REDIRECT',
    DirectResponse: 'DIRECT_RESPONSE'
} as const;

export type RouteRouteType = typeof RouteRouteType[keyof typeof RouteRouteType];


/**
 * 
 * @export
 * @interface SettingsListReply
 */
export interface SettingsListReply {
    /**
     * 
     * @type {string}
     * @memberof SettingsListReply
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface SettingsUpdateReply
 */
export interface SettingsUpdateReply {
    /**
     * 
     * @type {string}
     * @memberof SettingsUpdateReply
     */
    'message'?: string;
}

/**
 * AppServiceApi - axios parameter creator
 * @export
 */
export const AppServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AppApplication} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceCreate: async (body: AppApplication, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('appServiceCreate', 'body', body)
            const localVarPath = `/api/v1/apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('appServiceDelete', 'id', id)
            const localVarPath = `/api/v1/apps/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject5} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceDoAction: async (id: string, body: InlineObject5, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('appServiceDoAction', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('appServiceDoAction', 'body', body)
            const localVarPath = `/api/v1/apps/{id}/actions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [pid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceList: async (pid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pid !== undefined) {
                localVarQueryParameter['pid'] = pid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceRead: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('appServiceRead', 'id', id)
            const localVarPath = `/api/v1/apps/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} payloadId 
         * @param {InlineObject10} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceUpdate: async (payloadId: string, payload: InlineObject10, updateMask?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payloadId' is not null or undefined
            assertParamExists('appServiceUpdate', 'payloadId', payloadId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('appServiceUpdate', 'payload', payload)
            const localVarPath = `/api/v1/apps/{payload.id}`
                .replace(`{${"payload.id"}}`, encodeURIComponent(String(payloadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (updateMask !== undefined) {
                localVarQueryParameter['updateMask'] = updateMask;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} payloadId 
         * @param {InlineObject11} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceUpdate2: async (payloadId: string, payload: InlineObject11, updateMask?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payloadId' is not null or undefined
            assertParamExists('appServiceUpdate2', 'payloadId', payloadId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('appServiceUpdate2', 'payload', payload)
            const localVarPath = `/api/v1/apps/{payload.id}`
                .replace(`{${"payload.id"}}`, encodeURIComponent(String(payloadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (updateMask !== undefined) {
                localVarQueryParameter['updateMask'] = updateMask;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppServiceApi - functional programming interface
 * @export
 */
export const AppServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AppApplication} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceCreate(body: AppApplication, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject5} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceDoAction(id: string, body: InlineObject5, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceDoAction(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [pid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceList(pid?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceList(pid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceRead(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} payloadId 
         * @param {InlineObject10} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceUpdate(payloadId: string, payload: InlineObject10, updateMask?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceUpdate(payloadId, payload, updateMask, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} payloadId 
         * @param {InlineObject11} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceUpdate2(payloadId: string, payload: InlineObject11, updateMask?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceUpdate2(payloadId, payload, updateMask, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AppServiceApi - factory interface
 * @export
 */
export const AppServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {AppApplication} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceCreate(body: AppApplication, options?: any): AxiosPromise<AppApplication> {
            return localVarFp.appServiceCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceDelete(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.appServiceDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject5} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceDoAction(id: string, body: InlineObject5, options?: any): AxiosPromise<AppApplication> {
            return localVarFp.appServiceDoAction(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [pid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceList(pid?: string, options?: any): AxiosPromise<AppListResponse> {
            return localVarFp.appServiceList(pid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceRead(id: string, options?: any): AxiosPromise<AppApplication> {
            return localVarFp.appServiceRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} payloadId 
         * @param {InlineObject10} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceUpdate(payloadId: string, payload: InlineObject10, updateMask?: string, options?: any): AxiosPromise<AppApplication> {
            return localVarFp.appServiceUpdate(payloadId, payload, updateMask, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} payloadId 
         * @param {InlineObject11} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceUpdate2(payloadId: string, payload: InlineObject11, updateMask?: string, options?: any): AxiosPromise<AppApplication> {
            return localVarFp.appServiceUpdate2(payloadId, payload, updateMask, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppServiceApi - object-oriented interface
 * @export
 * @class AppServiceApi
 * @extends {BaseAPI}
 */
export class AppServiceApi extends BaseAPI {
    /**
     * 
     * @param {AppApplication} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceCreate(body: AppApplication, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceDelete(id: string, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {InlineObject5} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceDoAction(id: string, body: InlineObject5, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceDoAction(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [pid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceList(pid?: string, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceList(pid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceRead(id: string, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} payloadId 
     * @param {InlineObject10} payload 
     * @param {string} [updateMask] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceUpdate(payloadId: string, payload: InlineObject10, updateMask?: string, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceUpdate(payloadId, payload, updateMask, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} payloadId 
     * @param {InlineObject11} payload 
     * @param {string} [updateMask] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceUpdate2(payloadId: string, payload: InlineObject11, updateMask?: string, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceUpdate2(payloadId, payload, updateMask, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EgressServiceApi - axios parameter creator
 * @export
 */
export const EgressServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} appid 
         * @param {InlineObject} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egressServiceCreate: async (appid: string, body: InlineObject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appid' is not null or undefined
            assertParamExists('egressServiceCreate', 'appid', appid)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('egressServiceCreate', 'body', body)
            const localVarPath = `/api/v1/apps/{appid}/egress`
                .replace(`{${"appid"}}`, encodeURIComponent(String(appid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} id2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egressServiceDelete: async (id: string, id2: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('egressServiceDelete', 'id', id)
            // verify required parameter 'id2' is not null or undefined
            assertParamExists('egressServiceDelete', 'id2', id2)
            const localVarPath = `/api/v1/apps/{id}/egress/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id2)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egressServiceList: async (appid: string, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appid' is not null or undefined
            assertParamExists('egressServiceList', 'appid', appid)
            const localVarPath = `/api/v1/apps/{appid}/egress`
                .replace(`{${"appid"}}`, encodeURIComponent(String(appid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} id 
         * @param {InlineObject1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egressServiceUpdate: async (appid: string, id: string, body: InlineObject1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appid' is not null or undefined
            assertParamExists('egressServiceUpdate', 'appid', appid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('egressServiceUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('egressServiceUpdate', 'body', body)
            const localVarPath = `/api/v1/apps/{appid}/egress/{id}`
                .replace(`{${"appid"}}`, encodeURIComponent(String(appid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} id 
         * @param {InlineObject2} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egressServiceUpdate2: async (appid: string, id: string, body: InlineObject2, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appid' is not null or undefined
            assertParamExists('egressServiceUpdate2', 'appid', appid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('egressServiceUpdate2', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('egressServiceUpdate2', 'body', body)
            const localVarPath = `/api/v1/apps/{appid}/egress/{id}`
                .replace(`{${"appid"}}`, encodeURIComponent(String(appid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EgressServiceApi - functional programming interface
 * @export
 */
export const EgressServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EgressServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} appid 
         * @param {InlineObject} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async egressServiceCreate(appid: string, body: InlineObject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EgressEgress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.egressServiceCreate(appid, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} id2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async egressServiceDelete(id: string, id2: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.egressServiceDelete(id, id2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async egressServiceList(appid: string, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EgressListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.egressServiceList(appid, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} id 
         * @param {InlineObject1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async egressServiceUpdate(appid: string, id: string, body: InlineObject1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EgressEgress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.egressServiceUpdate(appid, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} id 
         * @param {InlineObject2} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async egressServiceUpdate2(appid: string, id: string, body: InlineObject2, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EgressEgress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.egressServiceUpdate2(appid, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EgressServiceApi - factory interface
 * @export
 */
export const EgressServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EgressServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} appid 
         * @param {InlineObject} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egressServiceCreate(appid: string, body: InlineObject, options?: any): AxiosPromise<EgressEgress> {
            return localVarFp.egressServiceCreate(appid, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} id2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egressServiceDelete(id: string, id2: string, options?: any): AxiosPromise<object> {
            return localVarFp.egressServiceDelete(id, id2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egressServiceList(appid: string, name?: string, options?: any): AxiosPromise<EgressListResponse> {
            return localVarFp.egressServiceList(appid, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} id 
         * @param {InlineObject1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egressServiceUpdate(appid: string, id: string, body: InlineObject1, options?: any): AxiosPromise<EgressEgress> {
            return localVarFp.egressServiceUpdate(appid, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} id 
         * @param {InlineObject2} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egressServiceUpdate2(appid: string, id: string, body: InlineObject2, options?: any): AxiosPromise<EgressEgress> {
            return localVarFp.egressServiceUpdate2(appid, id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EgressServiceApi - object-oriented interface
 * @export
 * @class EgressServiceApi
 * @extends {BaseAPI}
 */
export class EgressServiceApi extends BaseAPI {
    /**
     * 
     * @param {string} appid 
     * @param {InlineObject} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EgressServiceApi
     */
    public egressServiceCreate(appid: string, body: InlineObject, options?: AxiosRequestConfig) {
        return EgressServiceApiFp(this.configuration).egressServiceCreate(appid, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} id2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EgressServiceApi
     */
    public egressServiceDelete(id: string, id2: string, options?: AxiosRequestConfig) {
        return EgressServiceApiFp(this.configuration).egressServiceDelete(id, id2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appid 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EgressServiceApi
     */
    public egressServiceList(appid: string, name?: string, options?: AxiosRequestConfig) {
        return EgressServiceApiFp(this.configuration).egressServiceList(appid, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appid 
     * @param {string} id 
     * @param {InlineObject1} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EgressServiceApi
     */
    public egressServiceUpdate(appid: string, id: string, body: InlineObject1, options?: AxiosRequestConfig) {
        return EgressServiceApiFp(this.configuration).egressServiceUpdate(appid, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appid 
     * @param {string} id 
     * @param {InlineObject2} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EgressServiceApi
     */
    public egressServiceUpdate2(appid: string, id: string, body: InlineObject2, options?: AxiosRequestConfig) {
        return EgressServiceApiFp(this.configuration).egressServiceUpdate2(appid, id, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EntryServiceApi - axios parameter creator
 * @export
 */
export const EntryServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} appid 
         * @param {InlineObject3} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entryServiceCreate: async (appid: string, body: InlineObject3, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appid' is not null or undefined
            assertParamExists('entryServiceCreate', 'appid', appid)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('entryServiceCreate', 'body', body)
            const localVarPath = `/api/v1/apps/{appid}/entries`
                .replace(`{${"appid"}}`, encodeURIComponent(String(appid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} id2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entryServiceDelete: async (id: string, id2: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('entryServiceDelete', 'id', id)
            // verify required parameter 'id2' is not null or undefined
            assertParamExists('entryServiceDelete', 'id2', id2)
            const localVarPath = `/api/v1/apps/{id}/entries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id2)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entryServiceList: async (appid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appid' is not null or undefined
            assertParamExists('entryServiceList', 'appid', appid)
            const localVarPath = `/api/v1/apps/{appid}/entries`
                .replace(`{${"appid"}}`, encodeURIComponent(String(appid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} payloadAppid 
         * @param {string} payloadId 
         * @param {InlineObject6} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entryServiceUpdate: async (payloadAppid: string, payloadId: string, payload: InlineObject6, updateMask?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payloadAppid' is not null or undefined
            assertParamExists('entryServiceUpdate', 'payloadAppid', payloadAppid)
            // verify required parameter 'payloadId' is not null or undefined
            assertParamExists('entryServiceUpdate', 'payloadId', payloadId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('entryServiceUpdate', 'payload', payload)
            const localVarPath = `/api/v1/apps/{payload.appid}/entries/{payload.id}`
                .replace(`{${"payload.appid"}}`, encodeURIComponent(String(payloadAppid)))
                .replace(`{${"payload.id"}}`, encodeURIComponent(String(payloadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (updateMask !== undefined) {
                localVarQueryParameter['updateMask'] = updateMask;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} payloadAppid 
         * @param {string} payloadId 
         * @param {InlineObject7} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entryServiceUpdate2: async (payloadAppid: string, payloadId: string, payload: InlineObject7, updateMask?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payloadAppid' is not null or undefined
            assertParamExists('entryServiceUpdate2', 'payloadAppid', payloadAppid)
            // verify required parameter 'payloadId' is not null or undefined
            assertParamExists('entryServiceUpdate2', 'payloadId', payloadId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('entryServiceUpdate2', 'payload', payload)
            const localVarPath = `/api/v1/apps/{payload.appid}/entries/{payload.id}`
                .replace(`{${"payload.appid"}}`, encodeURIComponent(String(payloadAppid)))
                .replace(`{${"payload.id"}}`, encodeURIComponent(String(payloadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (updateMask !== undefined) {
                localVarQueryParameter['updateMask'] = updateMask;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntryServiceApi - functional programming interface
 * @export
 */
export const EntryServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntryServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} appid 
         * @param {InlineObject3} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async entryServiceCreate(appid: string, body: InlineObject3, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntryEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.entryServiceCreate(appid, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} id2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async entryServiceDelete(id: string, id2: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.entryServiceDelete(id, id2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async entryServiceList(appid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntryListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.entryServiceList(appid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} payloadAppid 
         * @param {string} payloadId 
         * @param {InlineObject6} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async entryServiceUpdate(payloadAppid: string, payloadId: string, payload: InlineObject6, updateMask?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntryEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.entryServiceUpdate(payloadAppid, payloadId, payload, updateMask, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} payloadAppid 
         * @param {string} payloadId 
         * @param {InlineObject7} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async entryServiceUpdate2(payloadAppid: string, payloadId: string, payload: InlineObject7, updateMask?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntryEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.entryServiceUpdate2(payloadAppid, payloadId, payload, updateMask, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EntryServiceApi - factory interface
 * @export
 */
export const EntryServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntryServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} appid 
         * @param {InlineObject3} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entryServiceCreate(appid: string, body: InlineObject3, options?: any): AxiosPromise<EntryEntry> {
            return localVarFp.entryServiceCreate(appid, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} id2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entryServiceDelete(id: string, id2: string, options?: any): AxiosPromise<object> {
            return localVarFp.entryServiceDelete(id, id2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entryServiceList(appid: string, options?: any): AxiosPromise<EntryListResponse> {
            return localVarFp.entryServiceList(appid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} payloadAppid 
         * @param {string} payloadId 
         * @param {InlineObject6} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entryServiceUpdate(payloadAppid: string, payloadId: string, payload: InlineObject6, updateMask?: string, options?: any): AxiosPromise<EntryEntry> {
            return localVarFp.entryServiceUpdate(payloadAppid, payloadId, payload, updateMask, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} payloadAppid 
         * @param {string} payloadId 
         * @param {InlineObject7} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entryServiceUpdate2(payloadAppid: string, payloadId: string, payload: InlineObject7, updateMask?: string, options?: any): AxiosPromise<EntryEntry> {
            return localVarFp.entryServiceUpdate2(payloadAppid, payloadId, payload, updateMask, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EntryServiceApi - object-oriented interface
 * @export
 * @class EntryServiceApi
 * @extends {BaseAPI}
 */
export class EntryServiceApi extends BaseAPI {
    /**
     * 
     * @param {string} appid 
     * @param {InlineObject3} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntryServiceApi
     */
    public entryServiceCreate(appid: string, body: InlineObject3, options?: AxiosRequestConfig) {
        return EntryServiceApiFp(this.configuration).entryServiceCreate(appid, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} id2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntryServiceApi
     */
    public entryServiceDelete(id: string, id2: string, options?: AxiosRequestConfig) {
        return EntryServiceApiFp(this.configuration).entryServiceDelete(id, id2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntryServiceApi
     */
    public entryServiceList(appid: string, options?: AxiosRequestConfig) {
        return EntryServiceApiFp(this.configuration).entryServiceList(appid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} payloadAppid 
     * @param {string} payloadId 
     * @param {InlineObject6} payload 
     * @param {string} [updateMask] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntryServiceApi
     */
    public entryServiceUpdate(payloadAppid: string, payloadId: string, payload: InlineObject6, updateMask?: string, options?: AxiosRequestConfig) {
        return EntryServiceApiFp(this.configuration).entryServiceUpdate(payloadAppid, payloadId, payload, updateMask, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} payloadAppid 
     * @param {string} payloadId 
     * @param {InlineObject7} payload 
     * @param {string} [updateMask] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntryServiceApi
     */
    public entryServiceUpdate2(payloadAppid: string, payloadId: string, payload: InlineObject7, updateMask?: string, options?: AxiosRequestConfig) {
        return EntryServiceApiFp(this.configuration).entryServiceUpdate2(payloadAppid, payloadId, payload, updateMask, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MiddlewareServiceApi - axios parameter creator
 * @export
 */
export const MiddlewareServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MiddlewareClaim} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceClaimCreate: async (body: MiddlewareClaim, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('middlewareServiceClaimCreate', 'body', body)
            const localVarPath = `/api/v1/middleware/claims`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceClaimDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('middlewareServiceClaimDelete', 'id', id)
            const localVarPath = `/api/v1/middleware/claims/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject12} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceClaimUpdate: async (id: string, body: InlineObject12, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('middlewareServiceClaimUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('middlewareServiceClaimUpdate', 'body', body)
            const localVarPath = `/api/v1/middleware/claims/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject13} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceClaimUpdate2: async (id: string, body: InlineObject13, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('middlewareServiceClaimUpdate2', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('middlewareServiceClaimUpdate2', 'body', body)
            const localVarPath = `/api/v1/middleware/claims/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceClaims: async (type?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/middleware/claims`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MiddlewareInstance} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceCreate: async (body: MiddlewareInstance, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('middlewareServiceCreate', 'body', body)
            const localVarPath = `/api/v1/middlewares`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('middlewareServiceDelete', 'id', id)
            const localVarPath = `/api/v1/middlewares/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceList: async (type?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/middlewares`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject14} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceUpdate: async (id: string, body: InlineObject14, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('middlewareServiceUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('middlewareServiceUpdate', 'body', body)
            const localVarPath = `/api/v1/middlewares/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject15} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceUpdate2: async (id: string, body: InlineObject15, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('middlewareServiceUpdate2', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('middlewareServiceUpdate2', 'body', body)
            const localVarPath = `/api/v1/middlewares/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiddlewareServiceApi - functional programming interface
 * @export
 */
export const MiddlewareServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MiddlewareServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {MiddlewareClaim} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async middlewareServiceClaimCreate(body: MiddlewareClaim, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiddlewareClaim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.middlewareServiceClaimCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async middlewareServiceClaimDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.middlewareServiceClaimDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject12} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async middlewareServiceClaimUpdate(id: string, body: InlineObject12, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiddlewareClaim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.middlewareServiceClaimUpdate(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject13} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async middlewareServiceClaimUpdate2(id: string, body: InlineObject13, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiddlewareClaim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.middlewareServiceClaimUpdate2(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async middlewareServiceClaims(type?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiddlewareClaimsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.middlewareServiceClaims(type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {MiddlewareInstance} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async middlewareServiceCreate(body: MiddlewareInstance, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiddlewareInstance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.middlewareServiceCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async middlewareServiceDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.middlewareServiceDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async middlewareServiceList(type?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiddlewareListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.middlewareServiceList(type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject14} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async middlewareServiceUpdate(id: string, body: InlineObject14, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiddlewareInstance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.middlewareServiceUpdate(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject15} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async middlewareServiceUpdate2(id: string, body: InlineObject15, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiddlewareInstance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.middlewareServiceUpdate2(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MiddlewareServiceApi - factory interface
 * @export
 */
export const MiddlewareServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MiddlewareServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {MiddlewareClaim} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceClaimCreate(body: MiddlewareClaim, options?: any): AxiosPromise<MiddlewareClaim> {
            return localVarFp.middlewareServiceClaimCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceClaimDelete(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.middlewareServiceClaimDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject12} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceClaimUpdate(id: string, body: InlineObject12, options?: any): AxiosPromise<MiddlewareClaim> {
            return localVarFp.middlewareServiceClaimUpdate(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject13} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceClaimUpdate2(id: string, body: InlineObject13, options?: any): AxiosPromise<MiddlewareClaim> {
            return localVarFp.middlewareServiceClaimUpdate2(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceClaims(type?: string, options?: any): AxiosPromise<MiddlewareClaimsResponse> {
            return localVarFp.middlewareServiceClaims(type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MiddlewareInstance} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceCreate(body: MiddlewareInstance, options?: any): AxiosPromise<MiddlewareInstance> {
            return localVarFp.middlewareServiceCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceDelete(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.middlewareServiceDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceList(type?: string, options?: any): AxiosPromise<MiddlewareListResponse> {
            return localVarFp.middlewareServiceList(type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject14} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceUpdate(id: string, body: InlineObject14, options?: any): AxiosPromise<MiddlewareInstance> {
            return localVarFp.middlewareServiceUpdate(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject15} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceUpdate2(id: string, body: InlineObject15, options?: any): AxiosPromise<MiddlewareInstance> {
            return localVarFp.middlewareServiceUpdate2(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MiddlewareServiceApi - object-oriented interface
 * @export
 * @class MiddlewareServiceApi
 * @extends {BaseAPI}
 */
export class MiddlewareServiceApi extends BaseAPI {
    /**
     * 
     * @param {MiddlewareClaim} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiddlewareServiceApi
     */
    public middlewareServiceClaimCreate(body: MiddlewareClaim, options?: AxiosRequestConfig) {
        return MiddlewareServiceApiFp(this.configuration).middlewareServiceClaimCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiddlewareServiceApi
     */
    public middlewareServiceClaimDelete(id: string, options?: AxiosRequestConfig) {
        return MiddlewareServiceApiFp(this.configuration).middlewareServiceClaimDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {InlineObject12} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiddlewareServiceApi
     */
    public middlewareServiceClaimUpdate(id: string, body: InlineObject12, options?: AxiosRequestConfig) {
        return MiddlewareServiceApiFp(this.configuration).middlewareServiceClaimUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {InlineObject13} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiddlewareServiceApi
     */
    public middlewareServiceClaimUpdate2(id: string, body: InlineObject13, options?: AxiosRequestConfig) {
        return MiddlewareServiceApiFp(this.configuration).middlewareServiceClaimUpdate2(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiddlewareServiceApi
     */
    public middlewareServiceClaims(type?: string, options?: AxiosRequestConfig) {
        return MiddlewareServiceApiFp(this.configuration).middlewareServiceClaims(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MiddlewareInstance} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiddlewareServiceApi
     */
    public middlewareServiceCreate(body: MiddlewareInstance, options?: AxiosRequestConfig) {
        return MiddlewareServiceApiFp(this.configuration).middlewareServiceCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiddlewareServiceApi
     */
    public middlewareServiceDelete(id: string, options?: AxiosRequestConfig) {
        return MiddlewareServiceApiFp(this.configuration).middlewareServiceDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiddlewareServiceApi
     */
    public middlewareServiceList(type?: string, options?: AxiosRequestConfig) {
        return MiddlewareServiceApiFp(this.configuration).middlewareServiceList(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {InlineObject14} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiddlewareServiceApi
     */
    public middlewareServiceUpdate(id: string, body: InlineObject14, options?: AxiosRequestConfig) {
        return MiddlewareServiceApiFp(this.configuration).middlewareServiceUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {InlineObject15} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiddlewareServiceApi
     */
    public middlewareServiceUpdate2(id: string, body: InlineObject15, options?: AxiosRequestConfig) {
        return MiddlewareServiceApiFp(this.configuration).middlewareServiceUpdate2(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectServiceApi - axios parameter creator
 * @export
 */
export const ProjectServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ProjectProject} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceCreate: async (body: ProjectProject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('projectServiceCreate', 'body', body)
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectServiceDelete', 'id', id)
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceList: async (name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceRead: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectServiceRead', 'id', id)
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject16} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceUpdate: async (id: string, body: InlineObject16, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectServiceUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('projectServiceUpdate', 'body', body)
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject17} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceUpdate2: async (id: string, body: InlineObject17, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectServiceUpdate2', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('projectServiceUpdate2', 'body', body)
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectServiceApi - functional programming interface
 * @export
 */
export const ProjectServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ProjectProject} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectServiceCreate(body: ProjectProject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectServiceCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectServiceDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectServiceDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectServiceList(name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectServiceList(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectServiceRead(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectServiceRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject16} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectServiceUpdate(id: string, body: InlineObject16, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectServiceUpdate(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject17} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectServiceUpdate2(id: string, body: InlineObject17, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectServiceUpdate2(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectServiceApi - factory interface
 * @export
 */
export const ProjectServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {ProjectProject} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceCreate(body: ProjectProject, options?: any): AxiosPromise<ProjectProject> {
            return localVarFp.projectServiceCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceDelete(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.projectServiceDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceList(name?: string, options?: any): AxiosPromise<ProjectListResponse> {
            return localVarFp.projectServiceList(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceRead(id: string, options?: any): AxiosPromise<ProjectProject> {
            return localVarFp.projectServiceRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject16} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceUpdate(id: string, body: InlineObject16, options?: any): AxiosPromise<ProjectProject> {
            return localVarFp.projectServiceUpdate(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject17} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceUpdate2(id: string, body: InlineObject17, options?: any): AxiosPromise<ProjectProject> {
            return localVarFp.projectServiceUpdate2(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectServiceApi - object-oriented interface
 * @export
 * @class ProjectServiceApi
 * @extends {BaseAPI}
 */
export class ProjectServiceApi extends BaseAPI {
    /**
     * 
     * @param {ProjectProject} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public projectServiceCreate(body: ProjectProject, options?: AxiosRequestConfig) {
        return ProjectServiceApiFp(this.configuration).projectServiceCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public projectServiceDelete(id: string, options?: AxiosRequestConfig) {
        return ProjectServiceApiFp(this.configuration).projectServiceDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public projectServiceList(name?: string, options?: AxiosRequestConfig) {
        return ProjectServiceApiFp(this.configuration).projectServiceList(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public projectServiceRead(id: string, options?: AxiosRequestConfig) {
        return ProjectServiceApiFp(this.configuration).projectServiceRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {InlineObject16} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public projectServiceUpdate(id: string, body: InlineObject16, options?: AxiosRequestConfig) {
        return ProjectServiceApiFp(this.configuration).projectServiceUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {InlineObject17} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public projectServiceUpdate2(id: string, body: InlineObject17, options?: AxiosRequestConfig) {
        return ProjectServiceApiFp(this.configuration).projectServiceUpdate2(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RouteServiceApi - axios parameter creator
 * @export
 */
export const RouteServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} appid 
         * @param {InlineObject4} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeServiceCreate: async (appid: string, body: InlineObject4, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appid' is not null or undefined
            assertParamExists('routeServiceCreate', 'appid', appid)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('routeServiceCreate', 'body', body)
            const localVarPath = `/api/v1/apps/{appid}/routes`
                .replace(`{${"appid"}}`, encodeURIComponent(String(appid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} id2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeServiceDelete: async (id: string, id2: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('routeServiceDelete', 'id', id)
            // verify required parameter 'id2' is not null or undefined
            assertParamExists('routeServiceDelete', 'id2', id2)
            const localVarPath = `/api/v1/apps/{id}/routes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id2)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeServiceList: async (appid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appid' is not null or undefined
            assertParamExists('routeServiceList', 'appid', appid)
            const localVarPath = `/api/v1/apps/{appid}/routes`
                .replace(`{${"appid"}}`, encodeURIComponent(String(appid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} payloadAppid 
         * @param {string} payloadId 
         * @param {InlineObject8} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeServiceUpdate: async (payloadAppid: string, payloadId: string, payload: InlineObject8, updateMask?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payloadAppid' is not null or undefined
            assertParamExists('routeServiceUpdate', 'payloadAppid', payloadAppid)
            // verify required parameter 'payloadId' is not null or undefined
            assertParamExists('routeServiceUpdate', 'payloadId', payloadId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('routeServiceUpdate', 'payload', payload)
            const localVarPath = `/api/v1/apps/{payload.appid}/routes/{payload.id}`
                .replace(`{${"payload.appid"}}`, encodeURIComponent(String(payloadAppid)))
                .replace(`{${"payload.id"}}`, encodeURIComponent(String(payloadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (updateMask !== undefined) {
                localVarQueryParameter['updateMask'] = updateMask;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} payloadAppid 
         * @param {string} payloadId 
         * @param {InlineObject9} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeServiceUpdate2: async (payloadAppid: string, payloadId: string, payload: InlineObject9, updateMask?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payloadAppid' is not null or undefined
            assertParamExists('routeServiceUpdate2', 'payloadAppid', payloadAppid)
            // verify required parameter 'payloadId' is not null or undefined
            assertParamExists('routeServiceUpdate2', 'payloadId', payloadId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('routeServiceUpdate2', 'payload', payload)
            const localVarPath = `/api/v1/apps/{payload.appid}/routes/{payload.id}`
                .replace(`{${"payload.appid"}}`, encodeURIComponent(String(payloadAppid)))
                .replace(`{${"payload.id"}}`, encodeURIComponent(String(payloadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (updateMask !== undefined) {
                localVarQueryParameter['updateMask'] = updateMask;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RouteServiceApi - functional programming interface
 * @export
 */
export const RouteServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RouteServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} appid 
         * @param {InlineObject4} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeServiceCreate(appid: string, body: InlineObject4, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteRoute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeServiceCreate(appid, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} id2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeServiceDelete(id: string, id2: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeServiceDelete(id, id2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeServiceList(appid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeServiceList(appid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} payloadAppid 
         * @param {string} payloadId 
         * @param {InlineObject8} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeServiceUpdate(payloadAppid: string, payloadId: string, payload: InlineObject8, updateMask?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteRoute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeServiceUpdate(payloadAppid, payloadId, payload, updateMask, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} payloadAppid 
         * @param {string} payloadId 
         * @param {InlineObject9} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeServiceUpdate2(payloadAppid: string, payloadId: string, payload: InlineObject9, updateMask?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteRoute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeServiceUpdate2(payloadAppid, payloadId, payload, updateMask, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RouteServiceApi - factory interface
 * @export
 */
export const RouteServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RouteServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} appid 
         * @param {InlineObject4} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeServiceCreate(appid: string, body: InlineObject4, options?: any): AxiosPromise<RouteRoute> {
            return localVarFp.routeServiceCreate(appid, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} id2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeServiceDelete(id: string, id2: string, options?: any): AxiosPromise<object> {
            return localVarFp.routeServiceDelete(id, id2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeServiceList(appid: string, options?: any): AxiosPromise<RouteListResponse> {
            return localVarFp.routeServiceList(appid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} payloadAppid 
         * @param {string} payloadId 
         * @param {InlineObject8} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeServiceUpdate(payloadAppid: string, payloadId: string, payload: InlineObject8, updateMask?: string, options?: any): AxiosPromise<RouteRoute> {
            return localVarFp.routeServiceUpdate(payloadAppid, payloadId, payload, updateMask, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} payloadAppid 
         * @param {string} payloadId 
         * @param {InlineObject9} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeServiceUpdate2(payloadAppid: string, payloadId: string, payload: InlineObject9, updateMask?: string, options?: any): AxiosPromise<RouteRoute> {
            return localVarFp.routeServiceUpdate2(payloadAppid, payloadId, payload, updateMask, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RouteServiceApi - object-oriented interface
 * @export
 * @class RouteServiceApi
 * @extends {BaseAPI}
 */
export class RouteServiceApi extends BaseAPI {
    /**
     * 
     * @param {string} appid 
     * @param {InlineObject4} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RouteServiceApi
     */
    public routeServiceCreate(appid: string, body: InlineObject4, options?: AxiosRequestConfig) {
        return RouteServiceApiFp(this.configuration).routeServiceCreate(appid, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} id2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RouteServiceApi
     */
    public routeServiceDelete(id: string, id2: string, options?: AxiosRequestConfig) {
        return RouteServiceApiFp(this.configuration).routeServiceDelete(id, id2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RouteServiceApi
     */
    public routeServiceList(appid: string, options?: AxiosRequestConfig) {
        return RouteServiceApiFp(this.configuration).routeServiceList(appid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} payloadAppid 
     * @param {string} payloadId 
     * @param {InlineObject8} payload 
     * @param {string} [updateMask] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RouteServiceApi
     */
    public routeServiceUpdate(payloadAppid: string, payloadId: string, payload: InlineObject8, updateMask?: string, options?: AxiosRequestConfig) {
        return RouteServiceApiFp(this.configuration).routeServiceUpdate(payloadAppid, payloadId, payload, updateMask, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} payloadAppid 
     * @param {string} payloadId 
     * @param {InlineObject9} payload 
     * @param {string} [updateMask] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RouteServiceApi
     */
    public routeServiceUpdate2(payloadAppid: string, payloadId: string, payload: InlineObject9, updateMask?: string, options?: AxiosRequestConfig) {
        return RouteServiceApiFp(this.configuration).routeServiceUpdate2(payloadAppid, payloadId, payload, updateMask, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsServiceApi - axios parameter creator
 * @export
 */
export const SettingsServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsServiceList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsServiceApi - functional programming interface
 * @export
 */
export const SettingsServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsServiceList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingsListReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsServiceList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsServiceApi - factory interface
 * @export
 */
export const SettingsServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsServiceList(options?: any): AxiosPromise<SettingsListReply> {
            return localVarFp.settingsServiceList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsServiceApi - object-oriented interface
 * @export
 * @class SettingsServiceApi
 * @extends {BaseAPI}
 */
export class SettingsServiceApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsServiceApi
     */
    public settingsServiceList(options?: AxiosRequestConfig) {
        return SettingsServiceApiFp(this.configuration).settingsServiceList(options).then((request) => request(this.axios, this.basePath));
    }
}


