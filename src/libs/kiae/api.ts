/* tslint:disable */
/* eslint-disable */
/**
 * kiae
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const ActionPayloadAction = {
    Start: 'START',
    Stop: 'STOP',
    Restart: 'RESTART'
} as const;

export type ActionPayloadAction = typeof ActionPayloadAction[keyof typeof ActionPayloadAction];


/**
 * 
 * @export
 * @interface AppApplication
 */
export interface AppApplication {
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'pid'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'image'?: string;
    /**
     * 
     * @type {Array<ProjectPort>}
     * @memberof AppApplication
     */
    'ports'?: Array<ProjectPort>;
    /**
     * 
     * @type {AppStatus}
     * @memberof AppApplication
     */
    'status'?: AppStatus;
    /**
     * 
     * @type {AppSize}
     * @memberof AppApplication
     */
    'size'?: AppSize;
    /**
     * 
     * @type {number}
     * @memberof AppApplication
     */
    'replicas'?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AppApplication
     */
    'annotations'?: { [key: string]: string; };
    /**
     * 
     * @type {AppHealthProbe}
     * @memberof AppApplication
     */
    'livenessProbe'?: AppHealthProbe;
    /**
     * 
     * @type {AppHealthProbe}
     * @memberof AppApplication
     */
    'readinessProbe'?: AppHealthProbe;
    /**
     * 
     * @type {Array<AppConfiguration>}
     * @memberof AppApplication
     */
    'configs'?: Array<AppConfiguration>;
    /**
     * 
     * @type {Array<AppEnvironment>}
     * @memberof AppApplication
     */
    'environments'?: Array<AppEnvironment>;
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppApplication
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @interface AppConfiguration
 */
export interface AppConfiguration {
    /**
     * 
     * @type {string}
     * @memberof AppConfiguration
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppConfiguration
     */
    'filename'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppConfiguration
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppConfiguration
     */
    'mountPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppConfiguration
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppConfiguration
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface AppEnvironment
 */
export interface AppEnvironment {
    /**
     * 
     * @type {AppEnvironmentType}
     * @memberof AppEnvironment
     */
    'type'?: AppEnvironmentType;
    /**
     * 
     * @type {string}
     * @memberof AppEnvironment
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppEnvironment
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppEnvironment
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppEnvironment
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AppEnvironmentType = {
    System: 'SYSTEM',
    Proj: 'PROJ',
    User: 'USER'
} as const;

export type AppEnvironmentType = typeof AppEnvironmentType[keyof typeof AppEnvironmentType];


/**
 * 
 * @export
 * @interface AppHealthProbe
 */
export interface AppHealthProbe {
    /**
     * 
     * @type {boolean}
     * @memberof AppHealthProbe
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof AppHealthProbe
     */
    'port'?: number;
    /**
     * 
     * @type {string}
     * @memberof AppHealthProbe
     */
    'path'?: string;
    /**
     * 
     * @type {number}
     * @memberof AppHealthProbe
     */
    'periodSeconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof AppHealthProbe
     */
    'timeoutSeconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof AppHealthProbe
     */
    'successThreshold'?: number;
    /**
     * 
     * @type {number}
     * @memberof AppHealthProbe
     */
    'failureThreshold'?: number;
    /**
     * 
     * @type {number}
     * @memberof AppHealthProbe
     */
    'initialDelaySeconds'?: number;
}
/**
 * 
 * @export
 * @interface AppListResponse
 */
export interface AppListResponse {
    /**
     * 
     * @type {Array<AppApplication>}
     * @memberof AppListResponse
     */
    'items'?: Array<AppApplication>;
    /**
     * 
     * @type {string}
     * @memberof AppListResponse
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AppSize = {
    Nano: 'SIZE_NANO',
    Mirco: 'SIZE_MIRCO',
    Mini: 'SIZE_MINI',
    Small: 'SIZE_SMALL',
    Medium: 'SIZE_MEDIUM',
    Large: 'SIZE_LARGE',
    Xlarge: 'SIZE_XLARGE',
    Xxlarge: 'SIZE_XXLARGE'
} as const;

export type AppSize = typeof AppSize[keyof typeof AppSize];


/**
 * 
 * @export
 * @enum {string}
 */

export const AppStatus = {
    Created: 'STATUS_CREATED',
    Running: 'STATUS_RUNNING',
    Stopped: 'STATUS_STOPPED'
} as const;

export type AppStatus = typeof AppStatus[keyof typeof AppStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const ClaimPolicy = {
    Reuse: 'REUSE',
    Create: 'CREATE'
} as const;

export type ClaimPolicy = typeof ClaimPolicy[keyof typeof ClaimPolicy];


/**
 * 
 * @export
 * @interface EgressEgress
 */
export interface EgressEgress {
    /**
     * 
     * @type {string}
     * @memberof EgressEgress
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EgressEgress
     */
    'appid'?: string;
    /**
     * 
     * @type {EgressEgressType}
     * @memberof EgressEgress
     */
    'type'?: EgressEgressType;
    /**
     * 
     * @type {string}
     * @memberof EgressEgress
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EgressEgress
     */
    'host'?: string;
    /**
     * 
     * @type {Array<EgressPort>}
     * @memberof EgressEgress
     */
    'ports'?: Array<EgressPort>;
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof EgressEgress
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof EgressEgress
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof EgressEgress
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EgressEgressType = {
    Internal: 'INTERNAL',
    Internet: 'INTERNET'
} as const;

export type EgressEgressType = typeof EgressEgressType[keyof typeof EgressEgressType];


/**
 * 
 * @export
 * @interface EgressListResponse
 */
export interface EgressListResponse {
    /**
     * 
     * @type {Array<EgressEgress>}
     * @memberof EgressListResponse
     */
    'items'?: Array<EgressEgress>;
    /**
     * 
     * @type {string}
     * @memberof EgressListResponse
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @interface EgressPort
 */
export interface EgressPort {
    /**
     * 
     * @type {number}
     * @memberof EgressPort
     */
    'number'?: number;
    /**
     * 
     * @type {string}
     * @memberof EgressPort
     */
    'protocol'?: string;
}
/**
 * 
 * @export
 * @interface EntryEntry
 */
export interface EntryEntry {
    /**
     * 
     * @type {string}
     * @memberof EntryEntry
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntryEntry
     */
    'appid'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntryEntry
     */
    'gateway'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntryEntry
     */
    'host'?: string;
    /**
     * 
     * @type {EntryScope}
     * @memberof EntryEntry
     */
    'scope'?: EntryScope;
    /**
     * 
     * @type {Array<string>}
     * @memberof EntryEntry
     */
    'routeIds'?: Array<string>;
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof EntryEntry
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof EntryEntry
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntryEntry
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface EntryListResponse
 */
export interface EntryListResponse {
    /**
     * 
     * @type {Array<EntryEntry>}
     * @memberof EntryListResponse
     */
    'items'?: Array<EntryEntry>;
    /**
     * 
     * @type {string}
     * @memberof EntryListResponse
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EntryScope = {
    All: 'ALL',
    Partial: 'PARTIAL'
} as const;

export type EntryScope = typeof EntryScope[keyof typeof EntryScope];


/**
 * 
 * @export
 * @interface GooglerpcStatus
 */
export interface GooglerpcStatus {
    /**
     * 
     * @type {number}
     * @memberof GooglerpcStatus
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GooglerpcStatus
     */
    'message'?: string;
    /**
     * 
     * @type {Array<ProtobufAny>}
     * @memberof GooglerpcStatus
     */
    'details'?: Array<ProtobufAny>;
}
/**
 * 
 * @export
 * @interface ImageImage
 */
export interface ImageImage {
    /**
     * 
     * @type {string}
     * @memberof ImageImage
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageImage
     */
    'pid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageImage
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageImage
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageImage
     */
    'tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageImage
     */
    'commit'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageImage
     */
    'url'?: string;
    /**
     * 
     * @type {ImageImageStatus}
     * @memberof ImageImage
     */
    'status'?: ImageImageStatus;
    /**
     * 
     * @type {string}
     * @memberof ImageImage
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageImage
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ImageImageListResponse
 */
export interface ImageImageListResponse {
    /**
     * 
     * @type {Array<ImageImage>}
     * @memberof ImageImageListResponse
     */
    'items'?: Array<ImageImage>;
    /**
     * 
     * @type {string}
     * @memberof ImageImageListResponse
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ImageImageStatus = {
    Building: 'BUILDING',
    Published: 'PUBLISHED',
    Expired: 'EXPIRED',
    Failed: 'FAILED'
} as const;

export type ImageImageStatus = typeof ImageImageStatus[keyof typeof ImageImageStatus];


/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'filename'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'mountPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    'id'?: string;
    /**
     * 
     * @type {EgressEgressType}
     * @memberof InlineObject1
     */
    'type'?: EgressEgressType;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    'host'?: string;
    /**
     * 
     * @type {Array<EgressPort>}
     * @memberof InlineObject1
     */
    'ports'?: Array<EgressPort>;
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof InlineObject1
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject10
 */
export interface InlineObject10 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject10
     */
    'path'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject10
     */
    'methods'?: Array<string>;
    /**
     * 
     * @type {RouteRouteType}
     * @memberof InlineObject10
     */
    'type'?: RouteRouteType;
    /**
     * 
     * @type {RouteForward}
     * @memberof InlineObject10
     */
    'forward'?: RouteForward;
    /**
     * 
     * @type {RouteRedirect}
     * @memberof InlineObject10
     */
    'redirect'?: RouteRedirect;
    /**
     * 
     * @type {RouteDirectResponse}
     * @memberof InlineObject10
     */
    'mock'?: RouteDirectResponse;
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof InlineObject10
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject10
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject10
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject10
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject10
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject11
 */
export interface InlineObject11 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject11
     */
    'path'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject11
     */
    'methods'?: Array<string>;
    /**
     * 
     * @type {RouteRouteType}
     * @memberof InlineObject11
     */
    'type'?: RouteRouteType;
    /**
     * 
     * @type {RouteForward}
     * @memberof InlineObject11
     */
    'forward'?: RouteForward;
    /**
     * 
     * @type {RouteRedirect}
     * @memberof InlineObject11
     */
    'redirect'?: RouteRedirect;
    /**
     * 
     * @type {RouteDirectResponse}
     * @memberof InlineObject11
     */
    'mock'?: RouteDirectResponse;
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof InlineObject11
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject11
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject11
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject11
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject11
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject12
 */
export interface InlineObject12 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    'pid'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    'image'?: string;
    /**
     * 
     * @type {Array<ProjectPort>}
     * @memberof InlineObject12
     */
    'ports'?: Array<ProjectPort>;
    /**
     * 
     * @type {AppStatus}
     * @memberof InlineObject12
     */
    'status'?: AppStatus;
    /**
     * 
     * @type {AppSize}
     * @memberof InlineObject12
     */
    'size'?: AppSize;
    /**
     * 
     * @type {number}
     * @memberof InlineObject12
     */
    'replicas'?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InlineObject12
     */
    'annotations'?: { [key: string]: string; };
    /**
     * 
     * @type {AppHealthProbe}
     * @memberof InlineObject12
     */
    'livenessProbe'?: AppHealthProbe;
    /**
     * 
     * @type {AppHealthProbe}
     * @memberof InlineObject12
     */
    'readinessProbe'?: AppHealthProbe;
    /**
     * 
     * @type {Array<AppConfiguration>}
     * @memberof InlineObject12
     */
    'configs'?: Array<AppConfiguration>;
    /**
     * 
     * @type {Array<AppEnvironment>}
     * @memberof InlineObject12
     */
    'environments'?: Array<AppEnvironment>;
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject13
 */
export interface InlineObject13 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    'pid'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    'image'?: string;
    /**
     * 
     * @type {Array<ProjectPort>}
     * @memberof InlineObject13
     */
    'ports'?: Array<ProjectPort>;
    /**
     * 
     * @type {AppStatus}
     * @memberof InlineObject13
     */
    'status'?: AppStatus;
    /**
     * 
     * @type {AppSize}
     * @memberof InlineObject13
     */
    'size'?: AppSize;
    /**
     * 
     * @type {number}
     * @memberof InlineObject13
     */
    'replicas'?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InlineObject13
     */
    'annotations'?: { [key: string]: string; };
    /**
     * 
     * @type {AppHealthProbe}
     * @memberof InlineObject13
     */
    'livenessProbe'?: AppHealthProbe;
    /**
     * 
     * @type {AppHealthProbe}
     * @memberof InlineObject13
     */
    'readinessProbe'?: AppHealthProbe;
    /**
     * 
     * @type {Array<AppConfiguration>}
     * @memberof InlineObject13
     */
    'configs'?: Array<AppConfiguration>;
    /**
     * 
     * @type {Array<AppEnvironment>}
     * @memberof InlineObject13
     */
    'environments'?: Array<AppEnvironment>;
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject14
 */
export interface InlineObject14 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject14
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject14
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject14
     */
    'tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject14
     */
    'commit'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject14
     */
    'url'?: string;
    /**
     * 
     * @type {ImageImageStatus}
     * @memberof InlineObject14
     */
    'status'?: ImageImageStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject14
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject14
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject15
 */
export interface InlineObject15 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject15
     */
    'appid'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject15
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject15
     */
    'name'?: string;
    /**
     * 
     * @type {ClaimPolicy}
     * @memberof InlineObject15
     */
    'policy'?: ClaimPolicy;
    /**
     * 
     * @type {string}
     * @memberof InlineObject15
     */
    'instance'?: string;
    /**
     * 
     * @type {MiddlewareClaimStatus}
     * @memberof InlineObject15
     */
    'status'?: MiddlewareClaimStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject15
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject15
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject16
 */
export interface InlineObject16 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject16
     */
    'appid'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject16
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject16
     */
    'name'?: string;
    /**
     * 
     * @type {ClaimPolicy}
     * @memberof InlineObject16
     */
    'policy'?: ClaimPolicy;
    /**
     * 
     * @type {string}
     * @memberof InlineObject16
     */
    'instance'?: string;
    /**
     * 
     * @type {MiddlewareClaimStatus}
     * @memberof InlineObject16
     */
    'status'?: MiddlewareClaimStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject16
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject16
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject17
 */
export interface InlineObject17 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject17
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject17
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject17
     */
    'type'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InlineObject17
     */
    'properties'?: { [key: string]: string; };
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof InlineObject17
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject17
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject17
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject18
 */
export interface InlineObject18 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject18
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject18
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject18
     */
    'type'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InlineObject18
     */
    'properties'?: { [key: string]: string; };
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof InlineObject18
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject18
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject18
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject19
 */
export interface InlineObject19 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject19
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject19
     */
    'intro'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject19
     */
    'gitRepo'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject19
     */
    'imageRepo'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject19
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject19
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject19
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject19
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * 
     * @type {EgressEgressType}
     * @memberof InlineObject2
     */
    'type'?: EgressEgressType;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    'host'?: string;
    /**
     * 
     * @type {Array<EgressPort>}
     * @memberof InlineObject2
     */
    'ports'?: Array<EgressPort>;
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof InlineObject2
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject20
 */
export interface InlineObject20 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject20
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject20
     */
    'intro'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject20
     */
    'gitRepo'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject20
     */
    'imageRepo'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject20
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject20
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject20
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject20
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject21
 */
export interface InlineObject21 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject21
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject21
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject21
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject21
     */
    'tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject21
     */
    'commit'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject21
     */
    'url'?: string;
    /**
     * 
     * @type {ImageImageStatus}
     * @memberof InlineObject21
     */
    'status'?: ImageImageStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject21
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject21
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject22
 */
export interface InlineObject22 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject22
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject22
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject22
     */
    'tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject22
     */
    'commit'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject22
     */
    'url'?: string;
    /**
     * 
     * @type {ImageImageStatus}
     * @memberof InlineObject22
     */
    'status'?: ImageImageStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject22
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject22
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject23
 */
export interface InlineObject23 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject23
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject23
     */
    'clientId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject23
     */
    'clientSecret'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject23
     */
    'authorizeUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject23
     */
    'tokenUrl'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject23
     */
    'scopes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InlineObject23
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject23
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject24
 */
export interface InlineObject24 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject24
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject24
     */
    'clientId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject24
     */
    'clientSecret'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject24
     */
    'authorizeUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject24
     */
    'tokenUrl'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject24
     */
    'scopes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InlineObject24
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject24
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * 
     * @type {EgressEgressType}
     * @memberof InlineObject3
     */
    'type'?: EgressEgressType;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    'host'?: string;
    /**
     * 
     * @type {Array<EgressPort>}
     * @memberof InlineObject3
     */
    'ports'?: Array<EgressPort>;
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof InlineObject3
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    'gateway'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    'host'?: string;
    /**
     * 
     * @type {EntryScope}
     * @memberof InlineObject4
     */
    'scope'?: EntryScope;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject4
     */
    'routeIds'?: Array<string>;
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof InlineObject4
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
    /**
     * 
     * @type {AppEnvironmentType}
     * @memberof InlineObject5
     */
    'type'?: AppEnvironmentType;
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    'path'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject6
     */
    'methods'?: Array<string>;
    /**
     * 
     * @type {RouteRouteType}
     * @memberof InlineObject6
     */
    'type'?: RouteRouteType;
    /**
     * 
     * @type {RouteForward}
     * @memberof InlineObject6
     */
    'forward'?: RouteForward;
    /**
     * 
     * @type {RouteRedirect}
     * @memberof InlineObject6
     */
    'redirect'?: RouteRedirect;
    /**
     * 
     * @type {RouteDirectResponse}
     * @memberof InlineObject6
     */
    'mock'?: RouteDirectResponse;
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof InlineObject6
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject7
 */
export interface InlineObject7 {
    /**
     * 
     * @type {ActionPayloadAction}
     * @memberof InlineObject7
     */
    'action'?: ActionPayloadAction;
}
/**
 * 
 * @export
 * @interface InlineObject8
 */
export interface InlineObject8 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    'gateway'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    'host'?: string;
    /**
     * 
     * @type {EntryScope}
     * @memberof InlineObject8
     */
    'scope'?: EntryScope;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject8
     */
    'routeIds'?: Array<string>;
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof InlineObject8
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject9
 */
export interface InlineObject9 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    'gateway'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    'host'?: string;
    /**
     * 
     * @type {EntryScope}
     * @memberof InlineObject9
     */
    'scope'?: EntryScope;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject9
     */
    'routeIds'?: Array<string>;
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof InlineObject9
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const KiaeOpStatus = {
    Disabled: 'OP_STATUS_DISABLED',
    Enabled: 'OP_STATUS_ENABLED'
} as const;

export type KiaeOpStatus = typeof KiaeOpStatus[keyof typeof KiaeOpStatus];


/**
 * 
 * @export
 * @interface MiddlewareClaim
 */
export interface MiddlewareClaim {
    /**
     * 
     * @type {string}
     * @memberof MiddlewareClaim
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareClaim
     */
    'appid'?: string;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareClaim
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareClaim
     */
    'name'?: string;
    /**
     * 
     * @type {ClaimPolicy}
     * @memberof MiddlewareClaim
     */
    'policy'?: ClaimPolicy;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareClaim
     */
    'instance'?: string;
    /**
     * 
     * @type {MiddlewareClaimStatus}
     * @memberof MiddlewareClaim
     */
    'status'?: MiddlewareClaimStatus;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareClaim
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareClaim
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MiddlewareClaimStatus = {
    Unbound: 'UNBOUND',
    Bound: 'BOUND'
} as const;

export type MiddlewareClaimStatus = typeof MiddlewareClaimStatus[keyof typeof MiddlewareClaimStatus];


/**
 * 
 * @export
 * @interface MiddlewareClaimsResponse
 */
export interface MiddlewareClaimsResponse {
    /**
     * 
     * @type {Array<MiddlewareClaim>}
     * @memberof MiddlewareClaimsResponse
     */
    'items'?: Array<MiddlewareClaim>;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareClaimsResponse
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @interface MiddlewareInstance
 */
export interface MiddlewareInstance {
    /**
     * 
     * @type {string}
     * @memberof MiddlewareInstance
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareInstance
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareInstance
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareInstance
     */
    'type'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof MiddlewareInstance
     */
    'properties'?: { [key: string]: string; };
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof MiddlewareInstance
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareInstance
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareInstance
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface MiddlewareListResponse
 */
export interface MiddlewareListResponse {
    /**
     * 
     * @type {Array<MiddlewareInstance>}
     * @memberof MiddlewareListResponse
     */
    'items'?: Array<MiddlewareInstance>;
    /**
     * 
     * @type {string}
     * @memberof MiddlewareListResponse
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @interface ProjectListResponse
 */
export interface ProjectListResponse {
    /**
     * 
     * @type {Array<ProjectProject>}
     * @memberof ProjectListResponse
     */
    'items'?: Array<ProjectProject>;
    /**
     * 
     * @type {string}
     * @memberof ProjectListResponse
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @interface ProjectPort
 */
export interface ProjectPort {
    /**
     * 
     * @type {number}
     * @memberof ProjectPort
     */
    'port'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectPort
     */
    'protocol'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectPort
     */
    'appProtocol'?: string;
}
/**
 * 
 * @export
 * @interface ProjectProject
 */
export interface ProjectProject {
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'intro'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'gitRepo'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'imageRepo'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'updatedBy'?: string;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }  Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...  Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON  The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
    [key: string]: object | any;

    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof ProtobufAny
     */
    '@type'?: string;
}
/**
 * 
 * @export
 * @interface ProviderBranch
 */
export interface ProviderBranch {
    /**
     * 
     * @type {string}
     * @memberof ProviderBranch
     */
    'name'?: string;
    /**
     * 
     * @type {ProviderCommit}
     * @memberof ProviderBranch
     */
    'commit'?: ProviderCommit;
}
/**
 * 
 * @export
 * @interface ProviderCommit
 */
export interface ProviderCommit {
    /**
     * 
     * @type {string}
     * @memberof ProviderCommit
     */
    'sha1'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderCommit
     */
    'shortId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderCommit
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderCommit
     */
    'committerName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderCommit
     */
    'committerEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderCommit
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderCommit
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ProviderListBranchesResponse
 */
export interface ProviderListBranchesResponse {
    /**
     * 
     * @type {Array<ProviderBranch>}
     * @memberof ProviderListBranchesResponse
     */
    'items'?: Array<ProviderBranch>;
    /**
     * 
     * @type {string}
     * @memberof ProviderListBranchesResponse
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @interface ProviderListReposResponse
 */
export interface ProviderListReposResponse {
    /**
     * 
     * @type {Array<ProviderRepo>}
     * @memberof ProviderListReposResponse
     */
    'items'?: Array<ProviderRepo>;
    /**
     * 
     * @type {string}
     * @memberof ProviderListReposResponse
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @interface ProviderListResponse
 */
export interface ProviderListResponse {
    /**
     * 
     * @type {Array<ProviderProvider>}
     * @memberof ProviderListResponse
     */
    'items'?: Array<ProviderProvider>;
    /**
     * 
     * @type {string}
     * @memberof ProviderListResponse
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @interface ProviderListTagsResponse
 */
export interface ProviderListTagsResponse {
    /**
     * 
     * @type {Array<ProviderTag>}
     * @memberof ProviderListTagsResponse
     */
    'items'?: Array<ProviderTag>;
    /**
     * 
     * @type {string}
     * @memberof ProviderListTagsResponse
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @interface ProviderPrepare
 */
export interface ProviderPrepare {
    /**
     * 
     * @type {string}
     * @memberof ProviderPrepare
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderPrepare
     */
    'authorizeUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderPrepare
     */
    'tokenUrl'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProviderPrepare
     */
    'scopes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ProviderPreparesResponse
 */
export interface ProviderPreparesResponse {
    /**
     * 
     * @type {Array<ProviderPrepare>}
     * @memberof ProviderPreparesResponse
     */
    'items'?: Array<ProviderPrepare>;
}
/**
 * 
 * @export
 * @interface ProviderProvider
 */
export interface ProviderProvider {
    /**
     * 
     * @type {string}
     * @memberof ProviderProvider
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderProvider
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderProvider
     */
    'clientId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderProvider
     */
    'clientSecret'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderProvider
     */
    'authorizeUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderProvider
     */
    'tokenUrl'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProviderProvider
     */
    'scopes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ProviderProvider
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderProvider
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ProviderRepo
 */
export interface ProviderRepo {
    /**
     * 
     * @type {string}
     * @memberof ProviderRepo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderRepo
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderRepo
     */
    'intro'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderRepo
     */
    'gitUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderRepo
     */
    'httpUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderRepo
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderRepo
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ProviderTag
 */
export interface ProviderTag {
    /**
     * 
     * @type {string}
     * @memberof ProviderTag
     */
    'name'?: string;
    /**
     * 
     * @type {ProviderCommit}
     * @memberof ProviderTag
     */
    'commit'?: ProviderCommit;
}
/**
 * 
 * @export
 * @interface RouteCors
 */
export interface RouteCors {
    /**
     * 
     * @type {boolean}
     * @memberof RouteCors
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof RouteCors
     */
    'allowOrigins'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RouteCors
     */
    'allowMethods'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RouteCors
     */
    'allowHeaders'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RouteCors
     */
    'exposeHeaders'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof RouteCors
     */
    'allowCredentials'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RouteCors
     */
    'maxAge'?: number;
}
/**
 * 
 * @export
 * @interface RouteDirectResponse
 */
export interface RouteDirectResponse {
    /**
     * 
     * @type {number}
     * @memberof RouteDirectResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof RouteDirectResponse
     */
    'body'?: string;
}
/**
 * 
 * @export
 * @interface RouteForward
 */
export interface RouteForward {
    /**
     * 
     * @type {RouteCors}
     * @memberof RouteForward
     */
    'cors'?: RouteCors;
    /**
     * 
     * @type {RouteRewrite}
     * @memberof RouteForward
     */
    'rewrite'?: RouteRewrite;
    /**
     * 
     * @type {RouteLimiter}
     * @memberof RouteForward
     */
    'limiter'?: RouteLimiter;
}
/**
 * 
 * @export
 * @interface RouteLimiter
 */
export interface RouteLimiter {
    /**
     * 
     * @type {boolean}
     * @memberof RouteLimiter
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RouteLimiter
     */
    'qps'?: number;
}
/**
 * 
 * @export
 * @interface RouteListResponse
 */
export interface RouteListResponse {
    /**
     * 
     * @type {Array<RouteRoute>}
     * @memberof RouteListResponse
     */
    'items'?: Array<RouteRoute>;
    /**
     * 
     * @type {string}
     * @memberof RouteListResponse
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @interface RouteRedirect
 */
export interface RouteRedirect {
    /**
     * 
     * @type {number}
     * @memberof RouteRedirect
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof RouteRedirect
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface RouteRewrite
 */
export interface RouteRewrite {
    /**
     * 
     * @type {boolean}
     * @memberof RouteRewrite
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RouteRewrite
     */
    'uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof RouteRewrite
     */
    'authority'?: string;
}
/**
 * 
 * @export
 * @interface RouteRoute
 */
export interface RouteRoute {
    /**
     * 
     * @type {string}
     * @memberof RouteRoute
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RouteRoute
     */
    'appid'?: string;
    /**
     * 
     * @type {string}
     * @memberof RouteRoute
     */
    'path'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RouteRoute
     */
    'methods'?: Array<string>;
    /**
     * 
     * @type {RouteRouteType}
     * @memberof RouteRoute
     */
    'type'?: RouteRouteType;
    /**
     * 
     * @type {RouteForward}
     * @memberof RouteRoute
     */
    'forward'?: RouteForward;
    /**
     * 
     * @type {RouteRedirect}
     * @memberof RouteRoute
     */
    'redirect'?: RouteRedirect;
    /**
     * 
     * @type {RouteDirectResponse}
     * @memberof RouteRoute
     */
    'mock'?: RouteDirectResponse;
    /**
     * 
     * @type {KiaeOpStatus}
     * @memberof RouteRoute
     */
    'status'?: KiaeOpStatus;
    /**
     * 
     * @type {string}
     * @memberof RouteRoute
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof RouteRoute
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof RouteRoute
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof RouteRoute
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RouteRouteType = {
    Forward: 'FORWARD',
    Redirect: 'REDIRECT',
    DirectResponse: 'DIRECT_RESPONSE'
} as const;

export type RouteRouteType = typeof RouteRouteType[keyof typeof RouteRouteType];


/**
 * 
 * @export
 * @interface SettingsListReply
 */
export interface SettingsListReply {
    /**
     * 
     * @type {string}
     * @memberof SettingsListReply
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface SettingsUpdateReply
 */
export interface SettingsUpdateReply {
    /**
     * 
     * @type {string}
     * @memberof SettingsUpdateReply
     */
    'message'?: string;
}

/**
 * AppServiceApi - axios parameter creator
 * @export
 */
export const AppServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} appid 
         * @param {AppConfiguration} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceCfgCreate: async (appid: string, payload: AppConfiguration, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appid' is not null or undefined
            assertParamExists('appServiceCfgCreate', 'appid', appid)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('appServiceCfgCreate', 'payload', payload)
            const localVarPath = `/api/v1/apps/{appid}/configs`
                .replace(`{${"appid"}}`, encodeURIComponent(String(appid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} payloadName 
         * @param {string} [payloadFilename] 
         * @param {string} [payloadContent] 
         * @param {string} [payloadMountPath] 
         * @param {string} [payloadCreatedAt] 
         * @param {string} [payloadUpdatedAt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceCfgDelete: async (appid: string, payloadName: string, payloadFilename?: string, payloadContent?: string, payloadMountPath?: string, payloadCreatedAt?: string, payloadUpdatedAt?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appid' is not null or undefined
            assertParamExists('appServiceCfgDelete', 'appid', appid)
            // verify required parameter 'payloadName' is not null or undefined
            assertParamExists('appServiceCfgDelete', 'payloadName', payloadName)
            const localVarPath = `/api/v1/apps/{appid}/configs/{payload.name}`
                .replace(`{${"appid"}}`, encodeURIComponent(String(appid)))
                .replace(`{${"payload.name"}}`, encodeURIComponent(String(payloadName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (payloadFilename !== undefined) {
                localVarQueryParameter['payload.filename'] = payloadFilename;
            }

            if (payloadContent !== undefined) {
                localVarQueryParameter['payload.content'] = payloadContent;
            }

            if (payloadMountPath !== undefined) {
                localVarQueryParameter['payload.mountPath'] = payloadMountPath;
            }

            if (payloadCreatedAt !== undefined) {
                localVarQueryParameter['payload.createdAt'] = (payloadCreatedAt as any instanceof Date) ?
                    (payloadCreatedAt as any).toISOString() :
                    payloadCreatedAt;
            }

            if (payloadUpdatedAt !== undefined) {
                localVarQueryParameter['payload.updatedAt'] = (payloadUpdatedAt as any instanceof Date) ?
                    (payloadUpdatedAt as any).toISOString() :
                    payloadUpdatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} payloadName 
         * @param {InlineObject} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceCfgUpdate: async (appid: string, payloadName: string, payload: InlineObject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appid' is not null or undefined
            assertParamExists('appServiceCfgUpdate', 'appid', appid)
            // verify required parameter 'payloadName' is not null or undefined
            assertParamExists('appServiceCfgUpdate', 'payloadName', payloadName)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('appServiceCfgUpdate', 'payload', payload)
            const localVarPath = `/api/v1/apps/{appid}/configs/{payload.name}`
                .replace(`{${"appid"}}`, encodeURIComponent(String(appid)))
                .replace(`{${"payload.name"}}`, encodeURIComponent(String(payloadName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AppApplication} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceCreate: async (body: AppApplication, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('appServiceCreate', 'body', body)
            const localVarPath = `/api/v1/apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('appServiceDelete', 'id', id)
            const localVarPath = `/api/v1/apps/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject7} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceDoAction: async (id: string, body: InlineObject7, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('appServiceDoAction', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('appServiceDoAction', 'body', body)
            const localVarPath = `/api/v1/apps/{id}/actions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appid 
         * @param {AppEnvironment} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceEnvCreate: async (appid: string, payload: AppEnvironment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appid' is not null or undefined
            assertParamExists('appServiceEnvCreate', 'appid', appid)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('appServiceEnvCreate', 'payload', payload)
            const localVarPath = `/api/v1/apps/{appid}/environments`
                .replace(`{${"appid"}}`, encodeURIComponent(String(appid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} payloadName 
         * @param {'SYSTEM' | 'PROJ' | 'USER'} [payloadType] 
         * @param {string} [payloadValue] 
         * @param {string} [payloadCreatedAt] 
         * @param {string} [payloadUpdatedAt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceEnvDelete: async (appid: string, payloadName: string, payloadType?: 'SYSTEM' | 'PROJ' | 'USER', payloadValue?: string, payloadCreatedAt?: string, payloadUpdatedAt?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appid' is not null or undefined
            assertParamExists('appServiceEnvDelete', 'appid', appid)
            // verify required parameter 'payloadName' is not null or undefined
            assertParamExists('appServiceEnvDelete', 'payloadName', payloadName)
            const localVarPath = `/api/v1/apps/{appid}/environments/{payload.name}`
                .replace(`{${"appid"}}`, encodeURIComponent(String(appid)))
                .replace(`{${"payload.name"}}`, encodeURIComponent(String(payloadName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (payloadType !== undefined) {
                localVarQueryParameter['payload.type'] = payloadType;
            }

            if (payloadValue !== undefined) {
                localVarQueryParameter['payload.value'] = payloadValue;
            }

            if (payloadCreatedAt !== undefined) {
                localVarQueryParameter['payload.createdAt'] = (payloadCreatedAt as any instanceof Date) ?
                    (payloadCreatedAt as any).toISOString() :
                    payloadCreatedAt;
            }

            if (payloadUpdatedAt !== undefined) {
                localVarQueryParameter['payload.updatedAt'] = (payloadUpdatedAt as any instanceof Date) ?
                    (payloadUpdatedAt as any).toISOString() :
                    payloadUpdatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} payloadName 
         * @param {InlineObject5} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceEnvUpdate: async (appid: string, payloadName: string, payload: InlineObject5, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appid' is not null or undefined
            assertParamExists('appServiceEnvUpdate', 'appid', appid)
            // verify required parameter 'payloadName' is not null or undefined
            assertParamExists('appServiceEnvUpdate', 'payloadName', payloadName)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('appServiceEnvUpdate', 'payload', payload)
            const localVarPath = `/api/v1/apps/{appid}/environments/{payload.name}`
                .replace(`{${"appid"}}`, encodeURIComponent(String(appid)))
                .replace(`{${"payload.name"}}`, encodeURIComponent(String(payloadName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [pid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceList: async (pid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pid !== undefined) {
                localVarQueryParameter['pid'] = pid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceRead: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('appServiceRead', 'id', id)
            const localVarPath = `/api/v1/apps/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} payloadId 
         * @param {InlineObject12} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceUpdate: async (payloadId: string, payload: InlineObject12, updateMask?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payloadId' is not null or undefined
            assertParamExists('appServiceUpdate', 'payloadId', payloadId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('appServiceUpdate', 'payload', payload)
            const localVarPath = `/api/v1/apps/{payload.id}`
                .replace(`{${"payload.id"}}`, encodeURIComponent(String(payloadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (updateMask !== undefined) {
                localVarQueryParameter['updateMask'] = updateMask;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} payloadId 
         * @param {InlineObject13} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceUpdate2: async (payloadId: string, payload: InlineObject13, updateMask?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payloadId' is not null or undefined
            assertParamExists('appServiceUpdate2', 'payloadId', payloadId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('appServiceUpdate2', 'payload', payload)
            const localVarPath = `/api/v1/apps/{payload.id}`
                .replace(`{${"payload.id"}}`, encodeURIComponent(String(payloadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (updateMask !== undefined) {
                localVarQueryParameter['updateMask'] = updateMask;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppServiceApi - functional programming interface
 * @export
 */
export const AppServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} appid 
         * @param {AppConfiguration} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceCfgCreate(appid: string, payload: AppConfiguration, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceCfgCreate(appid, payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} payloadName 
         * @param {string} [payloadFilename] 
         * @param {string} [payloadContent] 
         * @param {string} [payloadMountPath] 
         * @param {string} [payloadCreatedAt] 
         * @param {string} [payloadUpdatedAt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceCfgDelete(appid: string, payloadName: string, payloadFilename?: string, payloadContent?: string, payloadMountPath?: string, payloadCreatedAt?: string, payloadUpdatedAt?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceCfgDelete(appid, payloadName, payloadFilename, payloadContent, payloadMountPath, payloadCreatedAt, payloadUpdatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} payloadName 
         * @param {InlineObject} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceCfgUpdate(appid: string, payloadName: string, payload: InlineObject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceCfgUpdate(appid, payloadName, payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AppApplication} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceCreate(body: AppApplication, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject7} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceDoAction(id: string, body: InlineObject7, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceDoAction(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appid 
         * @param {AppEnvironment} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceEnvCreate(appid: string, payload: AppEnvironment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppEnvironment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceEnvCreate(appid, payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} payloadName 
         * @param {'SYSTEM' | 'PROJ' | 'USER'} [payloadType] 
         * @param {string} [payloadValue] 
         * @param {string} [payloadCreatedAt] 
         * @param {string} [payloadUpdatedAt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceEnvDelete(appid: string, payloadName: string, payloadType?: 'SYSTEM' | 'PROJ' | 'USER', payloadValue?: string, payloadCreatedAt?: string, payloadUpdatedAt?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceEnvDelete(appid, payloadName, payloadType, payloadValue, payloadCreatedAt, payloadUpdatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} payloadName 
         * @param {InlineObject5} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceEnvUpdate(appid: string, payloadName: string, payload: InlineObject5, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppEnvironment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceEnvUpdate(appid, payloadName, payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [pid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceList(pid?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceList(pid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceRead(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} payloadId 
         * @param {InlineObject12} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceUpdate(payloadId: string, payload: InlineObject12, updateMask?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceUpdate(payloadId, payload, updateMask, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} payloadId 
         * @param {InlineObject13} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appServiceUpdate2(payloadId: string, payload: InlineObject13, updateMask?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appServiceUpdate2(payloadId, payload, updateMask, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AppServiceApi - factory interface
 * @export
 */
export const AppServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} appid 
         * @param {AppConfiguration} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceCfgCreate(appid: string, payload: AppConfiguration, options?: any): AxiosPromise<AppConfiguration> {
            return localVarFp.appServiceCfgCreate(appid, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} payloadName 
         * @param {string} [payloadFilename] 
         * @param {string} [payloadContent] 
         * @param {string} [payloadMountPath] 
         * @param {string} [payloadCreatedAt] 
         * @param {string} [payloadUpdatedAt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceCfgDelete(appid: string, payloadName: string, payloadFilename?: string, payloadContent?: string, payloadMountPath?: string, payloadCreatedAt?: string, payloadUpdatedAt?: string, options?: any): AxiosPromise<object> {
            return localVarFp.appServiceCfgDelete(appid, payloadName, payloadFilename, payloadContent, payloadMountPath, payloadCreatedAt, payloadUpdatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} payloadName 
         * @param {InlineObject} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceCfgUpdate(appid: string, payloadName: string, payload: InlineObject, options?: any): AxiosPromise<AppConfiguration> {
            return localVarFp.appServiceCfgUpdate(appid, payloadName, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AppApplication} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceCreate(body: AppApplication, options?: any): AxiosPromise<AppApplication> {
            return localVarFp.appServiceCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceDelete(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.appServiceDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject7} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceDoAction(id: string, body: InlineObject7, options?: any): AxiosPromise<AppApplication> {
            return localVarFp.appServiceDoAction(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appid 
         * @param {AppEnvironment} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceEnvCreate(appid: string, payload: AppEnvironment, options?: any): AxiosPromise<AppEnvironment> {
            return localVarFp.appServiceEnvCreate(appid, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} payloadName 
         * @param {'SYSTEM' | 'PROJ' | 'USER'} [payloadType] 
         * @param {string} [payloadValue] 
         * @param {string} [payloadCreatedAt] 
         * @param {string} [payloadUpdatedAt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceEnvDelete(appid: string, payloadName: string, payloadType?: 'SYSTEM' | 'PROJ' | 'USER', payloadValue?: string, payloadCreatedAt?: string, payloadUpdatedAt?: string, options?: any): AxiosPromise<object> {
            return localVarFp.appServiceEnvDelete(appid, payloadName, payloadType, payloadValue, payloadCreatedAt, payloadUpdatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} payloadName 
         * @param {InlineObject5} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceEnvUpdate(appid: string, payloadName: string, payload: InlineObject5, options?: any): AxiosPromise<AppEnvironment> {
            return localVarFp.appServiceEnvUpdate(appid, payloadName, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [pid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceList(pid?: string, options?: any): AxiosPromise<AppListResponse> {
            return localVarFp.appServiceList(pid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceRead(id: string, options?: any): AxiosPromise<AppApplication> {
            return localVarFp.appServiceRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} payloadId 
         * @param {InlineObject12} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceUpdate(payloadId: string, payload: InlineObject12, updateMask?: string, options?: any): AxiosPromise<AppApplication> {
            return localVarFp.appServiceUpdate(payloadId, payload, updateMask, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} payloadId 
         * @param {InlineObject13} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appServiceUpdate2(payloadId: string, payload: InlineObject13, updateMask?: string, options?: any): AxiosPromise<AppApplication> {
            return localVarFp.appServiceUpdate2(payloadId, payload, updateMask, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppServiceApi - object-oriented interface
 * @export
 * @class AppServiceApi
 * @extends {BaseAPI}
 */
export class AppServiceApi extends BaseAPI {
    /**
     * 
     * @param {string} appid 
     * @param {AppConfiguration} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceCfgCreate(appid: string, payload: AppConfiguration, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceCfgCreate(appid, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appid 
     * @param {string} payloadName 
     * @param {string} [payloadFilename] 
     * @param {string} [payloadContent] 
     * @param {string} [payloadMountPath] 
     * @param {string} [payloadCreatedAt] 
     * @param {string} [payloadUpdatedAt] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceCfgDelete(appid: string, payloadName: string, payloadFilename?: string, payloadContent?: string, payloadMountPath?: string, payloadCreatedAt?: string, payloadUpdatedAt?: string, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceCfgDelete(appid, payloadName, payloadFilename, payloadContent, payloadMountPath, payloadCreatedAt, payloadUpdatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appid 
     * @param {string} payloadName 
     * @param {InlineObject} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceCfgUpdate(appid: string, payloadName: string, payload: InlineObject, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceCfgUpdate(appid, payloadName, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AppApplication} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceCreate(body: AppApplication, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceDelete(id: string, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {InlineObject7} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceDoAction(id: string, body: InlineObject7, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceDoAction(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appid 
     * @param {AppEnvironment} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceEnvCreate(appid: string, payload: AppEnvironment, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceEnvCreate(appid, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appid 
     * @param {string} payloadName 
     * @param {'SYSTEM' | 'PROJ' | 'USER'} [payloadType] 
     * @param {string} [payloadValue] 
     * @param {string} [payloadCreatedAt] 
     * @param {string} [payloadUpdatedAt] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceEnvDelete(appid: string, payloadName: string, payloadType?: 'SYSTEM' | 'PROJ' | 'USER', payloadValue?: string, payloadCreatedAt?: string, payloadUpdatedAt?: string, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceEnvDelete(appid, payloadName, payloadType, payloadValue, payloadCreatedAt, payloadUpdatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appid 
     * @param {string} payloadName 
     * @param {InlineObject5} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceEnvUpdate(appid: string, payloadName: string, payload: InlineObject5, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceEnvUpdate(appid, payloadName, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [pid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceList(pid?: string, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceList(pid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceRead(id: string, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} payloadId 
     * @param {InlineObject12} payload 
     * @param {string} [updateMask] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceUpdate(payloadId: string, payload: InlineObject12, updateMask?: string, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceUpdate(payloadId, payload, updateMask, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} payloadId 
     * @param {InlineObject13} payload 
     * @param {string} [updateMask] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppServiceApi
     */
    public appServiceUpdate2(payloadId: string, payload: InlineObject13, updateMask?: string, options?: AxiosRequestConfig) {
        return AppServiceApiFp(this.configuration).appServiceUpdate2(payloadId, payload, updateMask, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EgressServiceApi - axios parameter creator
 * @export
 */
export const EgressServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} appid 
         * @param {InlineObject1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egressServiceCreate: async (appid: string, body: InlineObject1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appid' is not null or undefined
            assertParamExists('egressServiceCreate', 'appid', appid)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('egressServiceCreate', 'body', body)
            const localVarPath = `/api/v1/apps/{appid}/egress`
                .replace(`{${"appid"}}`, encodeURIComponent(String(appid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} id2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egressServiceDelete: async (id: string, id2: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('egressServiceDelete', 'id', id)
            // verify required parameter 'id2' is not null or undefined
            assertParamExists('egressServiceDelete', 'id2', id2)
            const localVarPath = `/api/v1/apps/{id}/egress/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id2)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egressServiceList: async (appid: string, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appid' is not null or undefined
            assertParamExists('egressServiceList', 'appid', appid)
            const localVarPath = `/api/v1/apps/{appid}/egress`
                .replace(`{${"appid"}}`, encodeURIComponent(String(appid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} id 
         * @param {InlineObject2} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egressServiceUpdate: async (appid: string, id: string, body: InlineObject2, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appid' is not null or undefined
            assertParamExists('egressServiceUpdate', 'appid', appid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('egressServiceUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('egressServiceUpdate', 'body', body)
            const localVarPath = `/api/v1/apps/{appid}/egress/{id}`
                .replace(`{${"appid"}}`, encodeURIComponent(String(appid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} id 
         * @param {InlineObject3} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egressServiceUpdate2: async (appid: string, id: string, body: InlineObject3, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appid' is not null or undefined
            assertParamExists('egressServiceUpdate2', 'appid', appid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('egressServiceUpdate2', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('egressServiceUpdate2', 'body', body)
            const localVarPath = `/api/v1/apps/{appid}/egress/{id}`
                .replace(`{${"appid"}}`, encodeURIComponent(String(appid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EgressServiceApi - functional programming interface
 * @export
 */
export const EgressServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EgressServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} appid 
         * @param {InlineObject1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async egressServiceCreate(appid: string, body: InlineObject1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EgressEgress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.egressServiceCreate(appid, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} id2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async egressServiceDelete(id: string, id2: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.egressServiceDelete(id, id2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async egressServiceList(appid: string, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EgressListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.egressServiceList(appid, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} id 
         * @param {InlineObject2} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async egressServiceUpdate(appid: string, id: string, body: InlineObject2, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EgressEgress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.egressServiceUpdate(appid, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} id 
         * @param {InlineObject3} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async egressServiceUpdate2(appid: string, id: string, body: InlineObject3, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EgressEgress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.egressServiceUpdate2(appid, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EgressServiceApi - factory interface
 * @export
 */
export const EgressServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EgressServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} appid 
         * @param {InlineObject1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egressServiceCreate(appid: string, body: InlineObject1, options?: any): AxiosPromise<EgressEgress> {
            return localVarFp.egressServiceCreate(appid, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} id2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egressServiceDelete(id: string, id2: string, options?: any): AxiosPromise<object> {
            return localVarFp.egressServiceDelete(id, id2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egressServiceList(appid: string, name?: string, options?: any): AxiosPromise<EgressListResponse> {
            return localVarFp.egressServiceList(appid, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} id 
         * @param {InlineObject2} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egressServiceUpdate(appid: string, id: string, body: InlineObject2, options?: any): AxiosPromise<EgressEgress> {
            return localVarFp.egressServiceUpdate(appid, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appid 
         * @param {string} id 
         * @param {InlineObject3} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egressServiceUpdate2(appid: string, id: string, body: InlineObject3, options?: any): AxiosPromise<EgressEgress> {
            return localVarFp.egressServiceUpdate2(appid, id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EgressServiceApi - object-oriented interface
 * @export
 * @class EgressServiceApi
 * @extends {BaseAPI}
 */
export class EgressServiceApi extends BaseAPI {
    /**
     * 
     * @param {string} appid 
     * @param {InlineObject1} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EgressServiceApi
     */
    public egressServiceCreate(appid: string, body: InlineObject1, options?: AxiosRequestConfig) {
        return EgressServiceApiFp(this.configuration).egressServiceCreate(appid, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} id2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EgressServiceApi
     */
    public egressServiceDelete(id: string, id2: string, options?: AxiosRequestConfig) {
        return EgressServiceApiFp(this.configuration).egressServiceDelete(id, id2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appid 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EgressServiceApi
     */
    public egressServiceList(appid: string, name?: string, options?: AxiosRequestConfig) {
        return EgressServiceApiFp(this.configuration).egressServiceList(appid, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appid 
     * @param {string} id 
     * @param {InlineObject2} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EgressServiceApi
     */
    public egressServiceUpdate(appid: string, id: string, body: InlineObject2, options?: AxiosRequestConfig) {
        return EgressServiceApiFp(this.configuration).egressServiceUpdate(appid, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appid 
     * @param {string} id 
     * @param {InlineObject3} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EgressServiceApi
     */
    public egressServiceUpdate2(appid: string, id: string, body: InlineObject3, options?: AxiosRequestConfig) {
        return EgressServiceApiFp(this.configuration).egressServiceUpdate2(appid, id, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EntryServiceApi - axios parameter creator
 * @export
 */
export const EntryServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} appid 
         * @param {InlineObject4} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entryServiceCreate: async (appid: string, body: InlineObject4, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appid' is not null or undefined
            assertParamExists('entryServiceCreate', 'appid', appid)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('entryServiceCreate', 'body', body)
            const localVarPath = `/api/v1/apps/{appid}/entries`
                .replace(`{${"appid"}}`, encodeURIComponent(String(appid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} id2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entryServiceDelete: async (id: string, id2: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('entryServiceDelete', 'id', id)
            // verify required parameter 'id2' is not null or undefined
            assertParamExists('entryServiceDelete', 'id2', id2)
            const localVarPath = `/api/v1/apps/{id}/entries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id2)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entryServiceList: async (appid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appid' is not null or undefined
            assertParamExists('entryServiceList', 'appid', appid)
            const localVarPath = `/api/v1/apps/{appid}/entries`
                .replace(`{${"appid"}}`, encodeURIComponent(String(appid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} payloadAppid 
         * @param {string} payloadId 
         * @param {InlineObject8} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entryServiceUpdate: async (payloadAppid: string, payloadId: string, payload: InlineObject8, updateMask?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payloadAppid' is not null or undefined
            assertParamExists('entryServiceUpdate', 'payloadAppid', payloadAppid)
            // verify required parameter 'payloadId' is not null or undefined
            assertParamExists('entryServiceUpdate', 'payloadId', payloadId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('entryServiceUpdate', 'payload', payload)
            const localVarPath = `/api/v1/apps/{payload.appid}/entries/{payload.id}`
                .replace(`{${"payload.appid"}}`, encodeURIComponent(String(payloadAppid)))
                .replace(`{${"payload.id"}}`, encodeURIComponent(String(payloadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (updateMask !== undefined) {
                localVarQueryParameter['updateMask'] = updateMask;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} payloadAppid 
         * @param {string} payloadId 
         * @param {InlineObject9} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entryServiceUpdate2: async (payloadAppid: string, payloadId: string, payload: InlineObject9, updateMask?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payloadAppid' is not null or undefined
            assertParamExists('entryServiceUpdate2', 'payloadAppid', payloadAppid)
            // verify required parameter 'payloadId' is not null or undefined
            assertParamExists('entryServiceUpdate2', 'payloadId', payloadId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('entryServiceUpdate2', 'payload', payload)
            const localVarPath = `/api/v1/apps/{payload.appid}/entries/{payload.id}`
                .replace(`{${"payload.appid"}}`, encodeURIComponent(String(payloadAppid)))
                .replace(`{${"payload.id"}}`, encodeURIComponent(String(payloadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (updateMask !== undefined) {
                localVarQueryParameter['updateMask'] = updateMask;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntryServiceApi - functional programming interface
 * @export
 */
export const EntryServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntryServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} appid 
         * @param {InlineObject4} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async entryServiceCreate(appid: string, body: InlineObject4, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntryEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.entryServiceCreate(appid, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} id2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async entryServiceDelete(id: string, id2: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.entryServiceDelete(id, id2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async entryServiceList(appid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntryListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.entryServiceList(appid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} payloadAppid 
         * @param {string} payloadId 
         * @param {InlineObject8} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async entryServiceUpdate(payloadAppid: string, payloadId: string, payload: InlineObject8, updateMask?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntryEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.entryServiceUpdate(payloadAppid, payloadId, payload, updateMask, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} payloadAppid 
         * @param {string} payloadId 
         * @param {InlineObject9} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async entryServiceUpdate2(payloadAppid: string, payloadId: string, payload: InlineObject9, updateMask?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntryEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.entryServiceUpdate2(payloadAppid, payloadId, payload, updateMask, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EntryServiceApi - factory interface
 * @export
 */
export const EntryServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntryServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} appid 
         * @param {InlineObject4} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entryServiceCreate(appid: string, body: InlineObject4, options?: any): AxiosPromise<EntryEntry> {
            return localVarFp.entryServiceCreate(appid, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} id2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entryServiceDelete(id: string, id2: string, options?: any): AxiosPromise<object> {
            return localVarFp.entryServiceDelete(id, id2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entryServiceList(appid: string, options?: any): AxiosPromise<EntryListResponse> {
            return localVarFp.entryServiceList(appid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} payloadAppid 
         * @param {string} payloadId 
         * @param {InlineObject8} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entryServiceUpdate(payloadAppid: string, payloadId: string, payload: InlineObject8, updateMask?: string, options?: any): AxiosPromise<EntryEntry> {
            return localVarFp.entryServiceUpdate(payloadAppid, payloadId, payload, updateMask, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} payloadAppid 
         * @param {string} payloadId 
         * @param {InlineObject9} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entryServiceUpdate2(payloadAppid: string, payloadId: string, payload: InlineObject9, updateMask?: string, options?: any): AxiosPromise<EntryEntry> {
            return localVarFp.entryServiceUpdate2(payloadAppid, payloadId, payload, updateMask, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EntryServiceApi - object-oriented interface
 * @export
 * @class EntryServiceApi
 * @extends {BaseAPI}
 */
export class EntryServiceApi extends BaseAPI {
    /**
     * 
     * @param {string} appid 
     * @param {InlineObject4} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntryServiceApi
     */
    public entryServiceCreate(appid: string, body: InlineObject4, options?: AxiosRequestConfig) {
        return EntryServiceApiFp(this.configuration).entryServiceCreate(appid, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} id2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntryServiceApi
     */
    public entryServiceDelete(id: string, id2: string, options?: AxiosRequestConfig) {
        return EntryServiceApiFp(this.configuration).entryServiceDelete(id, id2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntryServiceApi
     */
    public entryServiceList(appid: string, options?: AxiosRequestConfig) {
        return EntryServiceApiFp(this.configuration).entryServiceList(appid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} payloadAppid 
     * @param {string} payloadId 
     * @param {InlineObject8} payload 
     * @param {string} [updateMask] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntryServiceApi
     */
    public entryServiceUpdate(payloadAppid: string, payloadId: string, payload: InlineObject8, updateMask?: string, options?: AxiosRequestConfig) {
        return EntryServiceApiFp(this.configuration).entryServiceUpdate(payloadAppid, payloadId, payload, updateMask, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} payloadAppid 
     * @param {string} payloadId 
     * @param {InlineObject9} payload 
     * @param {string} [updateMask] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntryServiceApi
     */
    public entryServiceUpdate2(payloadAppid: string, payloadId: string, payload: InlineObject9, updateMask?: string, options?: AxiosRequestConfig) {
        return EntryServiceApiFp(this.configuration).entryServiceUpdate2(payloadAppid, payloadId, payload, updateMask, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImageServiceApi - axios parameter creator
 * @export
 */
export const ImageServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} pid 
         * @param {InlineObject21} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageServiceCreate: async (pid: string, body: InlineObject21, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pid' is not null or undefined
            assertParamExists('imageServiceCreate', 'pid', pid)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('imageServiceCreate', 'body', body)
            const localVarPath = `/api/v1/projects/{pid}/images`
                .replace(`{${"pid"}}`, encodeURIComponent(String(pid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} id2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageServiceDelete: async (id: string, id2: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageServiceDelete', 'id', id)
            // verify required parameter 'id2' is not null or undefined
            assertParamExists('imageServiceDelete', 'id2', id2)
            const localVarPath = `/api/v1/projects/{id}/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id2)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageServiceList: async (pid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pid' is not null or undefined
            assertParamExists('imageServiceList', 'pid', pid)
            const localVarPath = `/api/v1/projects/{pid}/images`
                .replace(`{${"pid"}}`, encodeURIComponent(String(pid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} pid 
         * @param {string} id 
         * @param {InlineObject14} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageServiceUpdate: async (pid: string, id: string, body: InlineObject14, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pid' is not null or undefined
            assertParamExists('imageServiceUpdate', 'pid', pid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageServiceUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('imageServiceUpdate', 'body', body)
            const localVarPath = `/api/v1/images/projects/{pid}/{id}`
                .replace(`{${"pid"}}`, encodeURIComponent(String(pid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} pid 
         * @param {string} id 
         * @param {InlineObject22} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageServiceUpdate2: async (pid: string, id: string, body: InlineObject22, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pid' is not null or undefined
            assertParamExists('imageServiceUpdate2', 'pid', pid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageServiceUpdate2', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('imageServiceUpdate2', 'body', body)
            const localVarPath = `/api/v1/projects/{pid}/images/{id}`
                .replace(`{${"pid"}}`, encodeURIComponent(String(pid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageServiceApi - functional programming interface
 * @export
 */
export const ImageServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImageServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} pid 
         * @param {InlineObject21} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageServiceCreate(pid: string, body: InlineObject21, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageServiceCreate(pid, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} id2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageServiceDelete(id: string, id2: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageServiceDelete(id, id2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageServiceList(pid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageImageListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageServiceList(pid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} pid 
         * @param {string} id 
         * @param {InlineObject14} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageServiceUpdate(pid: string, id: string, body: InlineObject14, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageServiceUpdate(pid, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} pid 
         * @param {string} id 
         * @param {InlineObject22} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageServiceUpdate2(pid: string, id: string, body: InlineObject22, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageServiceUpdate2(pid, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImageServiceApi - factory interface
 * @export
 */
export const ImageServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImageServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} pid 
         * @param {InlineObject21} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageServiceCreate(pid: string, body: InlineObject21, options?: any): AxiosPromise<ImageImage> {
            return localVarFp.imageServiceCreate(pid, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} id2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageServiceDelete(id: string, id2: string, options?: any): AxiosPromise<object> {
            return localVarFp.imageServiceDelete(id, id2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} pid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageServiceList(pid: string, options?: any): AxiosPromise<ImageImageListResponse> {
            return localVarFp.imageServiceList(pid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} pid 
         * @param {string} id 
         * @param {InlineObject14} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageServiceUpdate(pid: string, id: string, body: InlineObject14, options?: any): AxiosPromise<ImageImage> {
            return localVarFp.imageServiceUpdate(pid, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} pid 
         * @param {string} id 
         * @param {InlineObject22} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageServiceUpdate2(pid: string, id: string, body: InlineObject22, options?: any): AxiosPromise<ImageImage> {
            return localVarFp.imageServiceUpdate2(pid, id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImageServiceApi - object-oriented interface
 * @export
 * @class ImageServiceApi
 * @extends {BaseAPI}
 */
export class ImageServiceApi extends BaseAPI {
    /**
     * 
     * @param {string} pid 
     * @param {InlineObject21} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public imageServiceCreate(pid: string, body: InlineObject21, options?: AxiosRequestConfig) {
        return ImageServiceApiFp(this.configuration).imageServiceCreate(pid, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} id2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public imageServiceDelete(id: string, id2: string, options?: AxiosRequestConfig) {
        return ImageServiceApiFp(this.configuration).imageServiceDelete(id, id2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} pid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public imageServiceList(pid: string, options?: AxiosRequestConfig) {
        return ImageServiceApiFp(this.configuration).imageServiceList(pid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} pid 
     * @param {string} id 
     * @param {InlineObject14} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public imageServiceUpdate(pid: string, id: string, body: InlineObject14, options?: AxiosRequestConfig) {
        return ImageServiceApiFp(this.configuration).imageServiceUpdate(pid, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} pid 
     * @param {string} id 
     * @param {InlineObject22} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public imageServiceUpdate2(pid: string, id: string, body: InlineObject22, options?: AxiosRequestConfig) {
        return ImageServiceApiFp(this.configuration).imageServiceUpdate2(pid, id, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MiddlewareServiceApi - axios parameter creator
 * @export
 */
export const MiddlewareServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MiddlewareClaim} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceClaimCreate: async (body: MiddlewareClaim, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('middlewareServiceClaimCreate', 'body', body)
            const localVarPath = `/api/v1/middleware/claims`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceClaimDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('middlewareServiceClaimDelete', 'id', id)
            const localVarPath = `/api/v1/middleware/claims/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject15} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceClaimUpdate: async (id: string, body: InlineObject15, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('middlewareServiceClaimUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('middlewareServiceClaimUpdate', 'body', body)
            const localVarPath = `/api/v1/middleware/claims/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject16} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceClaimUpdate2: async (id: string, body: InlineObject16, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('middlewareServiceClaimUpdate2', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('middlewareServiceClaimUpdate2', 'body', body)
            const localVarPath = `/api/v1/middleware/claims/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceClaims: async (type?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/middleware/claims`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MiddlewareInstance} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceCreate: async (body: MiddlewareInstance, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('middlewareServiceCreate', 'body', body)
            const localVarPath = `/api/v1/middlewares`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('middlewareServiceDelete', 'id', id)
            const localVarPath = `/api/v1/middlewares/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceList: async (type?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/middlewares`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject17} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceUpdate: async (id: string, body: InlineObject17, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('middlewareServiceUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('middlewareServiceUpdate', 'body', body)
            const localVarPath = `/api/v1/middlewares/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject18} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceUpdate2: async (id: string, body: InlineObject18, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('middlewareServiceUpdate2', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('middlewareServiceUpdate2', 'body', body)
            const localVarPath = `/api/v1/middlewares/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiddlewareServiceApi - functional programming interface
 * @export
 */
export const MiddlewareServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MiddlewareServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {MiddlewareClaim} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async middlewareServiceClaimCreate(body: MiddlewareClaim, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiddlewareClaim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.middlewareServiceClaimCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async middlewareServiceClaimDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.middlewareServiceClaimDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject15} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async middlewareServiceClaimUpdate(id: string, body: InlineObject15, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiddlewareClaim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.middlewareServiceClaimUpdate(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject16} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async middlewareServiceClaimUpdate2(id: string, body: InlineObject16, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiddlewareClaim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.middlewareServiceClaimUpdate2(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async middlewareServiceClaims(type?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiddlewareClaimsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.middlewareServiceClaims(type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {MiddlewareInstance} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async middlewareServiceCreate(body: MiddlewareInstance, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiddlewareInstance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.middlewareServiceCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async middlewareServiceDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.middlewareServiceDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async middlewareServiceList(type?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiddlewareListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.middlewareServiceList(type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject17} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async middlewareServiceUpdate(id: string, body: InlineObject17, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiddlewareInstance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.middlewareServiceUpdate(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject18} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async middlewareServiceUpdate2(id: string, body: InlineObject18, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiddlewareInstance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.middlewareServiceUpdate2(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MiddlewareServiceApi - factory interface
 * @export
 */
export const MiddlewareServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MiddlewareServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {MiddlewareClaim} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceClaimCreate(body: MiddlewareClaim, options?: any): AxiosPromise<MiddlewareClaim> {
            return localVarFp.middlewareServiceClaimCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceClaimDelete(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.middlewareServiceClaimDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject15} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceClaimUpdate(id: string, body: InlineObject15, options?: any): AxiosPromise<MiddlewareClaim> {
            return localVarFp.middlewareServiceClaimUpdate(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject16} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceClaimUpdate2(id: string, body: InlineObject16, options?: any): AxiosPromise<MiddlewareClaim> {
            return localVarFp.middlewareServiceClaimUpdate2(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceClaims(type?: string, options?: any): AxiosPromise<MiddlewareClaimsResponse> {
            return localVarFp.middlewareServiceClaims(type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MiddlewareInstance} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceCreate(body: MiddlewareInstance, options?: any): AxiosPromise<MiddlewareInstance> {
            return localVarFp.middlewareServiceCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceDelete(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.middlewareServiceDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceList(type?: string, options?: any): AxiosPromise<MiddlewareListResponse> {
            return localVarFp.middlewareServiceList(type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject17} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceUpdate(id: string, body: InlineObject17, options?: any): AxiosPromise<MiddlewareInstance> {
            return localVarFp.middlewareServiceUpdate(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject18} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        middlewareServiceUpdate2(id: string, body: InlineObject18, options?: any): AxiosPromise<MiddlewareInstance> {
            return localVarFp.middlewareServiceUpdate2(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MiddlewareServiceApi - object-oriented interface
 * @export
 * @class MiddlewareServiceApi
 * @extends {BaseAPI}
 */
export class MiddlewareServiceApi extends BaseAPI {
    /**
     * 
     * @param {MiddlewareClaim} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiddlewareServiceApi
     */
    public middlewareServiceClaimCreate(body: MiddlewareClaim, options?: AxiosRequestConfig) {
        return MiddlewareServiceApiFp(this.configuration).middlewareServiceClaimCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiddlewareServiceApi
     */
    public middlewareServiceClaimDelete(id: string, options?: AxiosRequestConfig) {
        return MiddlewareServiceApiFp(this.configuration).middlewareServiceClaimDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {InlineObject15} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiddlewareServiceApi
     */
    public middlewareServiceClaimUpdate(id: string, body: InlineObject15, options?: AxiosRequestConfig) {
        return MiddlewareServiceApiFp(this.configuration).middlewareServiceClaimUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {InlineObject16} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiddlewareServiceApi
     */
    public middlewareServiceClaimUpdate2(id: string, body: InlineObject16, options?: AxiosRequestConfig) {
        return MiddlewareServiceApiFp(this.configuration).middlewareServiceClaimUpdate2(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiddlewareServiceApi
     */
    public middlewareServiceClaims(type?: string, options?: AxiosRequestConfig) {
        return MiddlewareServiceApiFp(this.configuration).middlewareServiceClaims(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MiddlewareInstance} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiddlewareServiceApi
     */
    public middlewareServiceCreate(body: MiddlewareInstance, options?: AxiosRequestConfig) {
        return MiddlewareServiceApiFp(this.configuration).middlewareServiceCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiddlewareServiceApi
     */
    public middlewareServiceDelete(id: string, options?: AxiosRequestConfig) {
        return MiddlewareServiceApiFp(this.configuration).middlewareServiceDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiddlewareServiceApi
     */
    public middlewareServiceList(type?: string, options?: AxiosRequestConfig) {
        return MiddlewareServiceApiFp(this.configuration).middlewareServiceList(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {InlineObject17} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiddlewareServiceApi
     */
    public middlewareServiceUpdate(id: string, body: InlineObject17, options?: AxiosRequestConfig) {
        return MiddlewareServiceApiFp(this.configuration).middlewareServiceUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {InlineObject18} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiddlewareServiceApi
     */
    public middlewareServiceUpdate2(id: string, body: InlineObject18, options?: AxiosRequestConfig) {
        return MiddlewareServiceApiFp(this.configuration).middlewareServiceUpdate2(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectServiceApi - axios parameter creator
 * @export
 */
export const ProjectServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ProjectProject} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceCreate: async (body: ProjectProject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('projectServiceCreate', 'body', body)
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectServiceDelete', 'id', id)
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceList: async (name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceRead: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectServiceRead', 'id', id)
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject19} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceUpdate: async (id: string, body: InlineObject19, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectServiceUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('projectServiceUpdate', 'body', body)
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject20} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceUpdate2: async (id: string, body: InlineObject20, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectServiceUpdate2', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('projectServiceUpdate2', 'body', body)
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectServiceApi - functional programming interface
 * @export
 */
export const ProjectServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ProjectProject} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectServiceCreate(body: ProjectProject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectServiceCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectServiceDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectServiceDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectServiceList(name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectServiceList(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectServiceRead(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectServiceRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject19} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectServiceUpdate(id: string, body: InlineObject19, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectServiceUpdate(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject20} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectServiceUpdate2(id: string, body: InlineObject20, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectServiceUpdate2(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectServiceApi - factory interface
 * @export
 */
export const ProjectServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {ProjectProject} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceCreate(body: ProjectProject, options?: any): AxiosPromise<ProjectProject> {
            return localVarFp.projectServiceCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceDelete(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.projectServiceDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceList(name?: string, options?: any): AxiosPromise<ProjectListResponse> {
            return localVarFp.projectServiceList(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceRead(id: string, options?: any): AxiosPromise<ProjectProject> {
            return localVarFp.projectServiceRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject19} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceUpdate(id: string, body: InlineObject19, options?: any): AxiosPromise<ProjectProject> {
            return localVarFp.projectServiceUpdate(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {InlineObject20} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectServiceUpdate2(id: string, body: InlineObject20, options?: any): AxiosPromise<ProjectProject> {
            return localVarFp.projectServiceUpdate2(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectServiceApi - object-oriented interface
 * @export
 * @class ProjectServiceApi
 * @extends {BaseAPI}
 */
export class ProjectServiceApi extends BaseAPI {
    /**
     * 
     * @param {ProjectProject} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public projectServiceCreate(body: ProjectProject, options?: AxiosRequestConfig) {
        return ProjectServiceApiFp(this.configuration).projectServiceCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public projectServiceDelete(id: string, options?: AxiosRequestConfig) {
        return ProjectServiceApiFp(this.configuration).projectServiceDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public projectServiceList(name?: string, options?: AxiosRequestConfig) {
        return ProjectServiceApiFp(this.configuration).projectServiceList(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public projectServiceRead(id: string, options?: AxiosRequestConfig) {
        return ProjectServiceApiFp(this.configuration).projectServiceRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {InlineObject19} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public projectServiceUpdate(id: string, body: InlineObject19, options?: AxiosRequestConfig) {
        return ProjectServiceApiFp(this.configuration).projectServiceUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {InlineObject20} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectServiceApi
     */
    public projectServiceUpdate2(id: string, body: InlineObject20, options?: AxiosRequestConfig) {
        return ProjectServiceApiFp(this.configuration).projectServiceUpdate2(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProviderServiceApi - axios parameter creator
 * @export
 */
export const ProviderServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ProviderProvider} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerServiceCreate: async (body: ProviderProvider, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('providerServiceCreate', 'body', body)
            const localVarPath = `/api/v1/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerServiceDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('providerServiceDelete', 'id', id)
            const localVarPath = `/api/v1/providers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [appid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerServiceList: async (appid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (appid !== undefined) {
                localVarQueryParameter['appid'] = appid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} provider 
         * @param {string} repoName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerServiceListBranches: async (provider: string, repoName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('providerServiceListBranches', 'provider', provider)
            // verify required parameter 'repoName' is not null or undefined
            assertParamExists('providerServiceListBranches', 'repoName', repoName)
            const localVarPath = `/api/v1/providers/{provider}/repos/{repoName}/branches`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)))
                .replace(`{${"repoName"}}`, encodeURIComponent(String(repoName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerServiceListRepos: async (provider: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('providerServiceListRepos', 'provider', provider)
            const localVarPath = `/api/v1/providers/{provider}/repos`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} provider 
         * @param {string} repoName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerServiceListTags: async (provider: string, repoName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('providerServiceListTags', 'provider', provider)
            // verify required parameter 'repoName' is not null or undefined
            assertParamExists('providerServiceListTags', 'repoName', repoName)
            const localVarPath = `/api/v1/providers/{provider}/repos/{repoName}/commits`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)))
                .replace(`{${"repoName"}}`, encodeURIComponent(String(repoName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerServicePrepare: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/provider/prepares`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} payloadId 
         * @param {InlineObject23} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerServiceUpdate: async (payloadId: string, payload: InlineObject23, updateMask?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payloadId' is not null or undefined
            assertParamExists('providerServiceUpdate', 'payloadId', payloadId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('providerServiceUpdate', 'payload', payload)
            const localVarPath = `/api/v1/providers/{payload.id}`
                .replace(`{${"payload.id"}}`, encodeURIComponent(String(payloadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (updateMask !== undefined) {
                localVarQueryParameter['updateMask'] = updateMask;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} payloadId 
         * @param {InlineObject24} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerServiceUpdate2: async (payloadId: string, payload: InlineObject24, updateMask?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payloadId' is not null or undefined
            assertParamExists('providerServiceUpdate2', 'payloadId', payloadId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('providerServiceUpdate2', 'payload', payload)
            const localVarPath = `/api/v1/providers/{payload.id}`
                .replace(`{${"payload.id"}}`, encodeURIComponent(String(payloadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (updateMask !== undefined) {
                localVarQueryParameter['updateMask'] = updateMask;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProviderServiceApi - functional programming interface
 * @export
 */
export const ProviderServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProviderServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ProviderProvider} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerServiceCreate(body: ProviderProvider, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderProvider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerServiceCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerServiceDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerServiceDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [appid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerServiceList(appid?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerServiceList(appid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} provider 
         * @param {string} repoName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerServiceListBranches(provider: string, repoName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderListBranchesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerServiceListBranches(provider, repoName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerServiceListRepos(provider: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderListReposResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerServiceListRepos(provider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} provider 
         * @param {string} repoName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerServiceListTags(provider: string, repoName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderListTagsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerServiceListTags(provider, repoName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerServicePrepare(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderPreparesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerServicePrepare(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} payloadId 
         * @param {InlineObject23} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerServiceUpdate(payloadId: string, payload: InlineObject23, updateMask?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderProvider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerServiceUpdate(payloadId, payload, updateMask, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} payloadId 
         * @param {InlineObject24} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerServiceUpdate2(payloadId: string, payload: InlineObject24, updateMask?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderProvider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerServiceUpdate2(payloadId, payload, updateMask, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProviderServiceApi - factory interface
 * @export
 */
export const ProviderServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProviderServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {ProviderProvider} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerServiceCreate(body: ProviderProvider, options?: any): AxiosPromise<ProviderProvider> {
            return localVarFp.providerServiceCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerServiceDelete(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.providerServiceDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [appid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerServiceList(appid?: string, options?: any): AxiosPromise<ProviderListResponse> {
            return localVarFp.providerServiceList(appid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} provider 
         * @param {string} repoName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerServiceListBranches(provider: string, repoName: string, options?: any): AxiosPromise<ProviderListBranchesResponse> {
            return localVarFp.providerServiceListBranches(provider, repoName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerServiceListRepos(provider: string, options?: any): AxiosPromise<ProviderListReposResponse> {
            return localVarFp.providerServiceListRepos(provider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} provider 
         * @param {string} repoName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerServiceListTags(provider: string, repoName: string, options?: any): AxiosPromise<ProviderListTagsResponse> {
            return localVarFp.providerServiceListTags(provider, repoName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerServicePrepare(options?: any): AxiosPromise<ProviderPreparesResponse> {
            return localVarFp.providerServicePrepare(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} payloadId 
         * @param {InlineObject23} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerServiceUpdate(payloadId: string, payload: InlineObject23, updateMask?: string, options?: any): AxiosPromise<ProviderProvider> {
            return localVarFp.providerServiceUpdate(payloadId, payload, updateMask, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} payloadId 
         * @param {InlineObject24} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerServiceUpdate2(payloadId: string, payload: InlineObject24, updateMask?: string, options?: any): AxiosPromise<ProviderProvider> {
            return localVarFp.providerServiceUpdate2(payloadId, payload, updateMask, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProviderServiceApi - object-oriented interface
 * @export
 * @class ProviderServiceApi
 * @extends {BaseAPI}
 */
export class ProviderServiceApi extends BaseAPI {
    /**
     * 
     * @param {ProviderProvider} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderServiceApi
     */
    public providerServiceCreate(body: ProviderProvider, options?: AxiosRequestConfig) {
        return ProviderServiceApiFp(this.configuration).providerServiceCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderServiceApi
     */
    public providerServiceDelete(id: string, options?: AxiosRequestConfig) {
        return ProviderServiceApiFp(this.configuration).providerServiceDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [appid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderServiceApi
     */
    public providerServiceList(appid?: string, options?: AxiosRequestConfig) {
        return ProviderServiceApiFp(this.configuration).providerServiceList(appid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} provider 
     * @param {string} repoName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderServiceApi
     */
    public providerServiceListBranches(provider: string, repoName: string, options?: AxiosRequestConfig) {
        return ProviderServiceApiFp(this.configuration).providerServiceListBranches(provider, repoName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderServiceApi
     */
    public providerServiceListRepos(provider: string, options?: AxiosRequestConfig) {
        return ProviderServiceApiFp(this.configuration).providerServiceListRepos(provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} provider 
     * @param {string} repoName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderServiceApi
     */
    public providerServiceListTags(provider: string, repoName: string, options?: AxiosRequestConfig) {
        return ProviderServiceApiFp(this.configuration).providerServiceListTags(provider, repoName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderServiceApi
     */
    public providerServicePrepare(options?: AxiosRequestConfig) {
        return ProviderServiceApiFp(this.configuration).providerServicePrepare(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} payloadId 
     * @param {InlineObject23} payload 
     * @param {string} [updateMask] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderServiceApi
     */
    public providerServiceUpdate(payloadId: string, payload: InlineObject23, updateMask?: string, options?: AxiosRequestConfig) {
        return ProviderServiceApiFp(this.configuration).providerServiceUpdate(payloadId, payload, updateMask, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} payloadId 
     * @param {InlineObject24} payload 
     * @param {string} [updateMask] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderServiceApi
     */
    public providerServiceUpdate2(payloadId: string, payload: InlineObject24, updateMask?: string, options?: AxiosRequestConfig) {
        return ProviderServiceApiFp(this.configuration).providerServiceUpdate2(payloadId, payload, updateMask, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RouteServiceApi - axios parameter creator
 * @export
 */
export const RouteServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} appid 
         * @param {InlineObject6} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeServiceCreate: async (appid: string, body: InlineObject6, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appid' is not null or undefined
            assertParamExists('routeServiceCreate', 'appid', appid)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('routeServiceCreate', 'body', body)
            const localVarPath = `/api/v1/apps/{appid}/routes`
                .replace(`{${"appid"}}`, encodeURIComponent(String(appid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} id2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeServiceDelete: async (id: string, id2: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('routeServiceDelete', 'id', id)
            // verify required parameter 'id2' is not null or undefined
            assertParamExists('routeServiceDelete', 'id2', id2)
            const localVarPath = `/api/v1/apps/{id}/routes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id2)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeServiceList: async (appid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appid' is not null or undefined
            assertParamExists('routeServiceList', 'appid', appid)
            const localVarPath = `/api/v1/apps/{appid}/routes`
                .replace(`{${"appid"}}`, encodeURIComponent(String(appid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} payloadAppid 
         * @param {string} payloadId 
         * @param {InlineObject10} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeServiceUpdate: async (payloadAppid: string, payloadId: string, payload: InlineObject10, updateMask?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payloadAppid' is not null or undefined
            assertParamExists('routeServiceUpdate', 'payloadAppid', payloadAppid)
            // verify required parameter 'payloadId' is not null or undefined
            assertParamExists('routeServiceUpdate', 'payloadId', payloadId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('routeServiceUpdate', 'payload', payload)
            const localVarPath = `/api/v1/apps/{payload.appid}/routes/{payload.id}`
                .replace(`{${"payload.appid"}}`, encodeURIComponent(String(payloadAppid)))
                .replace(`{${"payload.id"}}`, encodeURIComponent(String(payloadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (updateMask !== undefined) {
                localVarQueryParameter['updateMask'] = updateMask;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} payloadAppid 
         * @param {string} payloadId 
         * @param {InlineObject11} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeServiceUpdate2: async (payloadAppid: string, payloadId: string, payload: InlineObject11, updateMask?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payloadAppid' is not null or undefined
            assertParamExists('routeServiceUpdate2', 'payloadAppid', payloadAppid)
            // verify required parameter 'payloadId' is not null or undefined
            assertParamExists('routeServiceUpdate2', 'payloadId', payloadId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('routeServiceUpdate2', 'payload', payload)
            const localVarPath = `/api/v1/apps/{payload.appid}/routes/{payload.id}`
                .replace(`{${"payload.appid"}}`, encodeURIComponent(String(payloadAppid)))
                .replace(`{${"payload.id"}}`, encodeURIComponent(String(payloadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (updateMask !== undefined) {
                localVarQueryParameter['updateMask'] = updateMask;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RouteServiceApi - functional programming interface
 * @export
 */
export const RouteServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RouteServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} appid 
         * @param {InlineObject6} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeServiceCreate(appid: string, body: InlineObject6, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteRoute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeServiceCreate(appid, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} id2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeServiceDelete(id: string, id2: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeServiceDelete(id, id2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} appid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeServiceList(appid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeServiceList(appid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} payloadAppid 
         * @param {string} payloadId 
         * @param {InlineObject10} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeServiceUpdate(payloadAppid: string, payloadId: string, payload: InlineObject10, updateMask?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteRoute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeServiceUpdate(payloadAppid, payloadId, payload, updateMask, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} payloadAppid 
         * @param {string} payloadId 
         * @param {InlineObject11} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeServiceUpdate2(payloadAppid: string, payloadId: string, payload: InlineObject11, updateMask?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteRoute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeServiceUpdate2(payloadAppid, payloadId, payload, updateMask, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RouteServiceApi - factory interface
 * @export
 */
export const RouteServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RouteServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} appid 
         * @param {InlineObject6} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeServiceCreate(appid: string, body: InlineObject6, options?: any): AxiosPromise<RouteRoute> {
            return localVarFp.routeServiceCreate(appid, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} id2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeServiceDelete(id: string, id2: string, options?: any): AxiosPromise<object> {
            return localVarFp.routeServiceDelete(id, id2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} appid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeServiceList(appid: string, options?: any): AxiosPromise<RouteListResponse> {
            return localVarFp.routeServiceList(appid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} payloadAppid 
         * @param {string} payloadId 
         * @param {InlineObject10} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeServiceUpdate(payloadAppid: string, payloadId: string, payload: InlineObject10, updateMask?: string, options?: any): AxiosPromise<RouteRoute> {
            return localVarFp.routeServiceUpdate(payloadAppid, payloadId, payload, updateMask, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} payloadAppid 
         * @param {string} payloadId 
         * @param {InlineObject11} payload 
         * @param {string} [updateMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeServiceUpdate2(payloadAppid: string, payloadId: string, payload: InlineObject11, updateMask?: string, options?: any): AxiosPromise<RouteRoute> {
            return localVarFp.routeServiceUpdate2(payloadAppid, payloadId, payload, updateMask, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RouteServiceApi - object-oriented interface
 * @export
 * @class RouteServiceApi
 * @extends {BaseAPI}
 */
export class RouteServiceApi extends BaseAPI {
    /**
     * 
     * @param {string} appid 
     * @param {InlineObject6} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RouteServiceApi
     */
    public routeServiceCreate(appid: string, body: InlineObject6, options?: AxiosRequestConfig) {
        return RouteServiceApiFp(this.configuration).routeServiceCreate(appid, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} id2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RouteServiceApi
     */
    public routeServiceDelete(id: string, id2: string, options?: AxiosRequestConfig) {
        return RouteServiceApiFp(this.configuration).routeServiceDelete(id, id2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} appid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RouteServiceApi
     */
    public routeServiceList(appid: string, options?: AxiosRequestConfig) {
        return RouteServiceApiFp(this.configuration).routeServiceList(appid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} payloadAppid 
     * @param {string} payloadId 
     * @param {InlineObject10} payload 
     * @param {string} [updateMask] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RouteServiceApi
     */
    public routeServiceUpdate(payloadAppid: string, payloadId: string, payload: InlineObject10, updateMask?: string, options?: AxiosRequestConfig) {
        return RouteServiceApiFp(this.configuration).routeServiceUpdate(payloadAppid, payloadId, payload, updateMask, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} payloadAppid 
     * @param {string} payloadId 
     * @param {InlineObject11} payload 
     * @param {string} [updateMask] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RouteServiceApi
     */
    public routeServiceUpdate2(payloadAppid: string, payloadId: string, payload: InlineObject11, updateMask?: string, options?: AxiosRequestConfig) {
        return RouteServiceApiFp(this.configuration).routeServiceUpdate2(payloadAppid, payloadId, payload, updateMask, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsServiceApi - axios parameter creator
 * @export
 */
export const SettingsServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsServiceList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsServiceApi - functional programming interface
 * @export
 */
export const SettingsServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsServiceList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingsListReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsServiceList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsServiceApi - factory interface
 * @export
 */
export const SettingsServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsServiceList(options?: any): AxiosPromise<SettingsListReply> {
            return localVarFp.settingsServiceList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsServiceApi - object-oriented interface
 * @export
 * @class SettingsServiceApi
 * @extends {BaseAPI}
 */
export class SettingsServiceApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsServiceApi
     */
    public settingsServiceList(options?: AxiosRequestConfig) {
        return SettingsServiceApiFp(this.configuration).settingsServiceList(options).then((request) => request(this.axios, this.basePath));
    }
}


